#########################################################################
#    ███    ███  ██████  ██████  ██    ██ ██      ███████
#    ████  ████ ██    ██ ██   ██ ██    ██ ██      ██
#    ██ ████ ██ ██    ██ ██   ██ ██    ██ ██      █████
#    ██  ██  ██ ██    ██ ██   ██ ██    ██ ██      ██
#    ██      ██  ██████  ██████   ██████  ███████ ███████
#########################################################################
# incl files

extended_summary: |
  This module contains a set of factory functions for setting up the
  observation models, for use in the tudat estimation framework


#########################################################################
#  ███████ ███   ██ ██    ██ ███    ███  ██████
#  ██      ████  ██ ██    ██ ████  ████ █
#  █████   ██ ██ ██ ██    ██ ██ ████ ██  █████
#  ██      ██  ████ ██    ██ ██  ██  ██       █
#  ███████ ██    ██  ██████  ██      ██ ██████
#########################################################################


enums:

  #    py::enum_< tom::LinkEndType >
  #        enum tudat::observation_models::LinkEndType
  - name: LinkEndType
    short_summary: "Enumeration of available link end types."
    #extended_summary: |
    #Enumeration of link end types supported by tudat.

    members:
      - name: unidentified_link_end
      - name: transmitter
      - name: reflector1
      - name: retransmitter
      - name: reflector2
      - name: reflector3
      - name: reflector4
      - name: receiver
      - name: observed_body


  #    py::enum_< tom::ObservableType >
  #        enum tudat::observation_models::ObservableType
  - name: ObservableType
    short_summary: "Enumeration of available observable types."
    #extended_summary: |
    #Enumeration of observable types supported by tudat.

    members:
      - name: one_way_range_type # [py]
      - name: angular_position_type # [py]
      - name: position_observable_type # [py]
      - name: one_way_doppler_type # [py]
      - name: one_way_differenced_range_type # [py]
      - name: n_way_range_type # [py]
      - name: two_way_doppler_type # [py]
      - name: euler_angle_313_observable_type # [py]
      - name: velocity_observable_type # [py]

      - name: one_way_range # [cpp]
      - name: angular_position # [cpp]
      - name: position_observable # [cpp]
      - name: one_way_doppler # [cpp]
      - name: one_way_differenced_range # [cpp]
      - name: n_way_range # [cpp]
      - name: two_way_doppler # [cpp]
      - name: euler_angle_313_observable # [cpp]
      - name: velocity_observable # [cpp]



  #    py::enum_< tom::ObservationViabilityType >
  #        enum tudat::observation_models::ObservationViabilityType
  - name: ObservationViabilityType
    short_summary: "Enumeration of observation viability criterion types."
    #extended_summary: |
    #Enumeration of observation viability criteria supported by tudat.

    members:
      - name: minimum_elevation_angle
      - name: body_avoidance_angle
      - name: body_occultation


  # (%!) ObservationDependentVariables not yet exposed, since associated functionality is too immature for end user


  ###### done


#########################################################################
#   ██████ ██          ██      ██████  ██████ ███████  ██████
#  ██      ██         ████    █       █       ██      █
#  ██      ██        ██  ██    █████   █████  █████    █████
#  ██      ██       ████████        █       █ ██            █
#   ██████ ███████ ██      ██ ██████  ██████  ███████ ██████
#########################################################################

classes:

  # (%!) notes:
  # - make distinction between struct and class ?
  # - I decided to explicitly refer to factory functions from derived classes? multitude of base and derived classes now...

  # breaking up grouping of all base and all derived classes, instead grouping by heritage
  #######################################################################

  - name: DopplerProperTimeRateSettings
    short_summary: "Base class to defining proper time rate settings."
    extended_summary: |
      Functional (base) class for settings of proper time rate (at a single link end) for one-way Doppler observation model settings.
      Specific proper time rate settings must be defined using an object derived from this class.
      The derived classes are made accessible via dedicated factory functions.

    # attributes: none exposed

    methods:
      - name: ctor # [cpp]
        #      - name: __init__ # [py]
        short_summary: "Constructor." # [cpp]
        extended_summary: "Instances of this class are typically not generated by the user. Settings objects for proper time rates should be instantiated through the factory functions of a derived class." # [cpp]


  - name: ObservationSettings # [py]
  - name: ObservationModelSettings # [cpp]
    short_summary: "Base class for defining observation settings."
    extended_summary: |
      Functional (base) class for settings of observation models.
      Observation model settings define at least the type and geometry of a given observation.
      They can furthermore set observation biases and/or corrections.
      Simple observation models settings that are fully characterised by these elements can be managed by this base class, which can be instantiated through dedicated factory functions, such as
      :func:`~tudatpy.numerical_simulation.estimation_setup.observation.one_way_range`, :func:`~tudatpy.numerical_simulation.estimation_setup.observation.cartesian_position`, :func:`~tudatpy.numerical_simulation.estimation_setup.observation.angular_position`, etc.
      Model settings for specific observation models that require additional information such as integration time, retransmission time, etc. must be defined using an object derived from this class.
      The derived classes are made accessible through further factory functions.

    # attributes: none exposed

    methods:
      - name: ctor # [cpp]
        #      - name: __init__ # [py]
        short_summary: "Constructor." # [cpp]
        extended_summary: "Instances of this class are typically not generated by the user. Settings objects for observation models should be instantiated through the factory functions of a derived class." # [cpp]


  - name: OneWayDopplerObservationSettings
    short_summary: "Class for defining the settings of one-way Doppler observation models."
    extended_summary: |
      :class:`~tudatpy.numerical_simulation.estimation_setup.observation.ObservationSettings` derived class for one-way Doppler observation model settings.
      Settings object can account for additional observation model aspects such as light time corrections and proper time rate settings.
      Instances of this class can be created via the :func:`~tudatpy.numerical_simulation.estimation_setup.observation.one_way_open_loop_doppler` factory function.

    # attributes: none exposed

    methods:
      - name: ctor # [cpp]
        #      - name: __init__ # [py]
        short_summary: "Constructor." # [cpp]
        extended_summary: "Instances of the `OneWayDopplerObservationSettings` class should be created via the `oneWayOpenLoopDoppler` factory function." # [cpp]


  - name: LightTimeCorrectionSettings
    short_summary: "Base class to defining light time correction settings."
    extended_summary: |
      Functional (base) class for settings of light time corrections.
      This class is not used for calculations of corrections, but is used for the purpose of defining the light time correction properties.
      Specific light time correction settings must be defined using an object derived from this class.
      The derived classes are made accessible via dedicated factory functions, such as e.g. :func:`~tudatpy.numerical_simulation.estimation_setup.observation.first_order_relativistic_light_time_correction`

    # attributes: none exposed

    methods:
      - name: ctor # [cpp]
        #      - name: __init__ # [py]
        short_summary: "Constructor." # [cpp]
        extended_summary: "Instances of this class are typically not generated by the user. Settings objects for light time corrections should be instantiated through the factory functions of a derived class." # [cpp]


  - name: ObservationBiasSettings
    short_summary: "Base class to defining observation bias settings."
    extended_summary: |
      Functional (base) class for settings of observation bias.
      Specific observation bias settings must be defined using an object derived from this class.
      The derived classes are made accessible via dedicated factory functions.

    # attributes: none exposed

    methods:
      - name: ctor # [cpp]
        #      - name: __init__ # [py]
        short_summary: "Constructor." # [cpp]
        extended_summary: "Instances of this class are typically not generated by the user. Settings objects for observation biases should be instantiated through the factory functions of a derived class." # [cpp]


  - name: ObservationSimulationSettings
    short_summary: "Base structure for defining observation simulation settings."
    extended_summary: |
      Functional (base) structure for settings of observation simulation.
      A simulation settings object defines observation times, noise and viability criteria for the :class:`~tudatpy.numerical_simulation.estimation.ObservationSimulator` object to which it is applied during the simulation of observations.
      Therefore, one simulation settings object can only refer to one combination of observable type and link geometry (LinkEnds).
      Typically, the user does not interact with this class directly, but defines specific observation simulation settings using an object derived from this class.

    # attributes: none exposed

    methods:
      - name: ctor # [cpp]
        #      - name: __init__ # [py]
        short_summary: "Constructor." # [cpp]
        extended_summary: "Instances of this class are typically not generated by the user. Settings objects for observation simulation times should be instantiated through the factory functions of a derived class." # [cpp]


  - name: TabulatedObservationSimulationSettings
    short_summary: "Structure for setting a list of observation times."
    extended_summary: |
      :class:`~tudatpy.numerical_simulation.estimation_setup.observation.ObservationSimulationSettings` derived structure for settings of observation simulation.
      A simulation settings object defines observation times, noise and viability criteria for the :class:`~tudatpy.numerical_simulation.estimation.ObservationSimulator` object to which it is applied during the simulation of observations.
      Therefore, one simulation settings object can only refer to one combination of observable type and link geometry (LinkEnds).

      In this structure, discrete time instances at which applicable observations are to be simulated are defined and stored in a rigid, "tabulated" form. Some observation times may be discarded due to the use of viability settings.
      Instances of this class can be created via the :func:`~tudatpy.numerical_simulation.estimation_setup.observation.tabulated_simulation_settings` and :func:`~tudatpy.numerical_simulation.estimation_setup.observation.create_tabulated_simulation_settings` factory functions. # [py]

    # attributes: none exposed

    methods:
      - name: ctor # [cpp]
        #      - name: __init__ # [py]
        short_summary: "Constructor." # [cpp]
        extended_summary: "Instances of the `TabulatedObservationSimulationSettings` class should be created via the `tabulatedObservationSimulationSettings` factory function." # [cpp]


  - name: ObservationViabilitySettings
    short_summary: "Class for defining observation viability calculator settings."
    extended_summary: |
      Class for defining the settings for observation viability calculator creation.
      Instances of this class can be created through various dedicated factory functions, such as :func:`~tudatpy.numerical_simulation.estimation_setup.observation.elevation_angle_viability`, :func:`~tudatpy.numerical_simulation.estimation_setup.observation.body_avoidance_viability` and :func:`~tudatpy.numerical_simulation.estimation_setup.observation.body_occultation_viability`

    # attributes: none exposed

    methods:
      - name: ctor # [cpp]
        #      - name: __init__ # [py]
        short_summary: "Constructor." # [cpp]
        extended_summary: "Instances of the `ObservationViabilitySettings` class should be created via the associated factory functions." # [cpp]



# (%!) ObservationDependentVariableSettings not yet exposed, since associated functionality is too immature for end user

  - name: ObservationDependentVariableSettings
    short_summary: "Base class for setting observation dependent variables."
    extended_summary: |
      Functional (base) class for setting observation dependent variables as part of the observation output.
      Note: The associated functionality is not yet mature enough for the end user. Class is exposed for development purposes only.

    # attributes: none exposed

    methods:
      - name: ctor # [cpp]
        #      - name: __init__ # [py]
        short_summary: "Constructor." # [cpp]
        extended_summary: "Instances of this class are typically not generated by the user. Settings objects for observation simulation times should be instantiated through the factory functions of a derived class." # [cpp]


  #######################################################################

##############################################################################
#  ███████ ██    ██ ███    ██  ██████ ████████ ██  ██████  ███    ██  ██████
#  ██      ██    ██ ████   ██ ██         ██    ██ ██    ██ ████   ██ █
#  █████   ██    ██ ██ ██  ██ ██         ██    ██ ██    ██ ██ ██  ██  █████
#  ██      ██    ██ ██  ██ ██ ██         ██    ██ ██    ██ ██  ██ ██       █
#  ██       ██████  ██   ████  ██████    ██    ██  ██████  ██   ████ ██████
##############################################################################

functions:

  ###############    LINK ENDS           ################################
  # (%!) will need to be worked over after typedefs are turned to classes
  # module functions

  - name: one_way_downlink_link_ends # [py]
    short_summary: "Function for defining one-way downlinks via LinkEnds types."
    extended_summary: |
      Function for defining single or multiple one-way downlinks.
      Multiple downlinks share the same transmitters, but may each have a different receiver.
      For each downlink, the returned list will contain an additional `LinkEnds` type.

    parameters:
      - name: transmitter # [py]
        type: Tuple[str, str] # [py]
        description: |
          `LinkEndId` type (tuple of strings), where the first entrance identifies the body and the second entry the reference point of the single transmitter link end.

      - name: receivers # [py]
        type: List[ Tuple[str, str] ] # [py]
        description: |
          List of `LinkEndId` types (tuple of strings), where for each tuple the first entrance identifies the body and the second entry the reference point of the receiver link end(s).

    returns:
      type: List[ Dict[:class:`~tudatpy.numerical_simulation.estimation_setup.observation.LinkEndType`, Tuple[str, str] ]  # [py]
      description: |
        List of one or more `LinkEnds` types, each defining the geometry for one one-way downlink.
        A `LinkEnds` type for a one one-way link is composed a dict with one `receiver` and one `transmitter` :class:`~tudatpy.numerical_simulation.estimation_setup.observation.LinkEndType` key, to each of which a `LinkEndId` type is mapped.

  #######################################################################

  - name: one_way_uplink_link_ends # [py]
    short_summary: "Function for defining one-way uplinks via LinkEnds types."
    extended_summary: |
      Function for defining single or multiple one-way uplinks.
      Multiple uplinks share the same receiver, but may each have a different transmitter.
      For each uplink, the returned list will contain an additional `LinkEnds` type.

    parameters:
      - name: transmitters # [py]
        type: List[ Tuple[str, str] ] # [py]
        description: |
          List of `LinkEndId` types (tuple of strings), where for each tuple the first entrance identifies the body and the second entry the reference point of the transmitter link end(s).

      - name: receiver # [py]
        type: Tuple[str, str] # [py]
        description: |
          `LinkEndId` type (tuple of strings), where the first entrance identifies the body and the second entry the reference point of the single receiver link end.

    returns:
      type: List[ Dict[:class:`~tudatpy.numerical_simulation.estimation_setup.observation.LinkEndType`, Tuple[str, str] ]  # [py]
      description: |
        List of one or more `LinkEnds` types, each defining the geometry for one one-way uplink.
        A `LinkEnds` type for a one one-way link is composed a dict with one `receiver` and one `transmitter` :class:`~tudatpy.numerical_simulation.estimation_setup.observation.LinkEndType` key, to each of which a `LinkEndId` type is mapped.


  ############### LIGHT-TIME CORRECTIONS ################################
  # factory functions

  - name: first_order_relativistic_light_time_correction # [py]
    short_summary: "Factory function for creating settings for first-order relativistic light-time corrections."
    extended_summary: |
      Factory function for creating settings for first-order relativistic light-time corrections: the correction to
      the light time of a (set of) stationary point masses, computed up to c−2 according to general relativity as formulated by e.g. Moyer (2000).
      One ambiguity in the model is the time at which the states of the perturbing bodies are evaluated. We distinguish two cases:

      * In the case where the perturbing body contains a link end of the observation (for instance perturbation due to Earth gravity field,
        with one of the link ends being an Earth-based station), the time at which the Earth’s state is evaluated equals the transmission time if Earth acts as transmitter, and reception time if
        Earth acts as receiver.
      * In other cases, where the perturbing body is not involved in the link ends, its state is evaluated at the midpoint time between transmitter and receiver.

    parameters:
      - name: perturbing_bodies
        type: str
        description: |
          A list containing the names of the bodies due to which the light-time correction is to be taken into account.

    returns:
      type: :class:`FirstOrderRelativisticLightTimeCorrectionSettings`  # [py]
      description: |
        Instance of the :class:`~tudatpy.numerical_simulation.estimation_setup.observation.LightTimeCorrectionSettings` derived :class:`FirstOrderRelativisticLightTimeCorrectionSettings` class,
        defining the settings for the light-time corrections


  ###############        BIASES 		 ################################
  # factory functions

  - name: absolute_bias # [py]
    short_summary: "Factory function for creating settings for an absolute observation bias."
    extended_summary: |
      Factory function for creating settings for an absolute observation bias. When calculating the observable value, applying this setting
      will take the physically ideal observation :math:`h`, and modify it to obtain the biased observation :math:`\tilde{h}` as follows:

      .. math::
         \tilde{h}=h+K

      where :math:`K` is the `bias_value`. For an observable with size greater than 1, :math:`K` is a vector and the addition is component-wise.

    parameters:
      - name: bias_value # [py]
        type: numpy.ndarray # [py]
        description: |
          A vector containing the bias that is to be applied to the observable. This vector should be the same size as the observable to which it is
          applied (*e.g.* size 1 for a range observable, size 2 for angular position, *etc*.)

    returns:
      type: :class:`ConstantObservationBiasSettings`  # [py]
      description: Instance of the :class:`~tudatpy.numerical_simulation.estimation_setup.observation.ObservationBiasSettings` derived :class:`ConstantObservationBiasSettings` class,
        defining the settings for a constant, absolute observation bias.

  #######################################################################

  - name: relative_bias # [py]
    short_summary: "Factory function for creating settings for a relative observation bias."
    extended_summary: |
      Factory function for creating settings for a relative observation bias. When calculating the observable value, applying this setting
      will take the physically ideal observation :math:`h`, and modify it to obtain the biased observation :math:`\tilde{h}` as follows:

      .. math::
         \tilde{h}=h(1+K)

      where :math:`K` is the`bias_value`. For an observable with size greater than 1, :math:`K` is a vector and the multiplication is component-wise.

    parameters:
      - name: bias_value # [py]
        type: numpy.ndarray # [py]
        description: |
          A vector containing the bias that is to be applied to the observable. This vector should be the same size as the observable to which it is
          applied (*e.g.* size 1 for a range observable, size 2 for angular position, *etc*.)

    returns:
      type: :class:`ConstantObservationBiasSettings`  # [py]
      description: |
        Instance of the :class:`~tudatpy.numerical_simulation.estimation_setup.observation.ObservationBiasSettings` derived :class:`ConstantObservationBiasSettings` class,
        defining the settings for a constant, relative observation bias.

  #######################################################################

  - name: arcwise_absolute_bias # [py]
    short_summary: "Factory function for creating settings for arc-wise absolute observation biases."
    extended_summary: |
      Factory function for creating settings for arc-wise absolute observation biases.
      This bias setting differs from the :class:`~tudatpy.numerical_simulation.estimation_setup.observation.absolute_bias` setting only through the option of setting the `bias_value` :math:`K` to a different values for each arc.

    parameters:

      - name: arc_start_times # [py]
        type: List[ float ] # [py]
        description: |
          List containing starting times for each arc.

      - name: bias_values # [py]
        type: List[ numpy.ndarray ] # [py]
        description: |
          List of arc-wise bias vectors that are to be applied to the given observable. The vectors should be the same size as the observable to which it is
          applied (*e.g.* size 1 for a range observable, size 2 for angular position, *etc*.)

      - name: reference_link_end_type # [py]
        type: :class:`LinkEndType` # [py]
        description: |
          Defines the link end (via the :class:`LinkEndType`) which is used as a reference for observation times.

    returns:
      type: :class:`ArcWiseConstantObservationBiasSettings`  # [py]
      description: Instance of the :class:`~tudatpy.numerical_simulation.estimation_setup.observation.ObservationBiasSettings` derived :class:`ArcWiseConstantObservationBiasSettings` class.

  #######################################################################

  - name: arcwise_absolute_bias # [py] # overload
    short_summary: "Factory function for creating settings for arc-wise absolute observation biases."
    extended_summary: |
      Factory function for creating settings for arc-wise absolute observation biases.
      This bias setting differs from the :class:`~tudatpy.numerical_simulation.estimation_setup.observation.absolute_bias` setting only through the option of setting the `bias_value` :math:`K` to a different values for each arc.

    parameters:

      - name: bias_values_per_start_time # [py]
        type: Dict[float, numpy.ndarray[numpy.float64[m, 1]]] # [py]
        description: |
          Dictionary, in which the bias value vectors for each arc are directly mapped to the starting times of the respective arc.
          The vectors should be the same size as the observable to which it is applied (*e.g.* size 1 for a range observable, size 2 for angular position, *etc*.)

      - name: reference_link_end_type # [py]
        type: :class:`LinkEndType` # [py]
        description: |
          Defines the link end (via the :class:`LinkEndType`) which is used as a reference for observation times.

    returns:
      type: :class:`ArcWiseConstantObservationBiasSettings`  # [py]
      description: Instance of the :class:`~tudatpy.numerical_simulation.estimation_setup.observation.ObservationBiasSettings` derived :class:`~tudatpy.numerical_simulation.estimation_setup.observation.ArcWiseConstantObservationBiasSettings` class.

  #######################################################################

  - name: arcwise_relative_bias # [py]
    short_summary: "Factory function for creating settings for arc-wise relative observation biases."
    extended_summary: |
      Factory function for creating settings for arc-wise relative observation biases.
      This bias setting differs from the :class:`~tudatpy.numerical_simulation.estimation_setup.observation.relative_bias` setting only through the option of setting the `bias_value` :math:`K` to a different values for each arc.

    parameters:

      - name: arc_start_times # [py]
        type: List[ float ] # [py]
        description: |
          List containing starting times for each arc.

      - name: bias_values # [py]
        type: List[ numpy.ndarray ] # [py]
        description: |
          List of arc-wise bias vectors that are to be applied to the given observable. The vectors should be the same size as the observable to which it is
          applied (*e.g.* size 1 for a range observable, size 2 for angular position, *etc*.)

      - name: reference_link_end_type # [py]
        type: :class:`LinkEndType` # [py]
        description: |
          Defines the link end (via the :class:`LinkEndType`) which is used as a reference for observation times.

    returns:
      type: :class:`ArcWiseConstantObservationBiasSettings`  # [py]
      description: Instance of the :class:`~tudatpy.numerical_simulation.estimation_setup.observation.ObservationBiasSettings` derived :class:`~tudatpy.numerical_simulation.estimation_setup.observation.ArcWiseConstantObservationBiasSettings` class.

  #######################################################################

  - name: arcwise_relative_bias # [py] # overload
    short_summary: "Factory function for creating settings for arc-wise relative observation biases."
    extended_summary: |
      Factory function for creating settings for arc-wise relative observation biases.
      This bias setting differs from the :class:`~tudatpy.numerical_simulation.estimation_setup.observation.relative_bias` setting only through the option of setting the `bias_value` :math:`K` to a different values for each arc.

    parameters:

      - name: bias_values_per_start_time # [py]
        type: Dict[float, numpy.ndarray[numpy.float64[m, 1]]] # [py]
        description: |
          Dictionary, in which the bias value vectors for each arc are directly mapped to the starting times of the respective arc.
          The vectors should be the same size as the observable to which it is applied (*e.g.* size 1 for a range observable, size 2 for angular position, *etc*.)

      - name: reference_link_end_type # [py]
        type: :class:`LinkEndType` # [py]
        description: |
          Defines the link end (via the :class:`LinkEndType`) which is used as a reference for observation times.

    returns:
      type: :class:`ArcWiseConstantObservationBiasSettings`  # [py]
      description: Instance of the :class:`~tudatpy.numerical_simulation.estimation_setup.observation.ObservationBiasSettings` derived :class:`~tudatpy.numerical_simulation.estimation_setup.observation.ArcWiseConstantObservationBiasSettings` class.

  #######################################################################

  - name: combined_bias # [py]
    short_summary: "Factory function for creating settings for a combined observation bias."
    extended_summary: |
      Factory function for creating settings for a combined observation bias, calculating by combining any number of bias types.
      Each contribution of the combined bias is computed from the unbiased observable, so when applying both a relative and absolute bias, we get:

      .. math::
         \tilde{h}=h+K_{a}+hK_{r}

      And, crucially:

      .. math::
         \tilde{h}\neq (h+K_{a})(1+K_{r})

      where :math:`K_{r}` and :math:`K_{a}` is the relative and absolute bias, respectively.

    parameters:
      - name: bias_list # [py]
        type: List[ class:`ObservationBiasSettings` ] # [py]
        description: |
          A list containing the bias the bias settings that are to be applied to the observable.

    returns:
      type: :class:`MultipleObservationBiasSettings`  # [py]
      description: Instance of the :class:`~tudatpy.numerical_simulation.estimation_setup.observation.ObservationBiasSettings` derived :class:`MultipleObservationBiasSettings` class,
        combining the settings for multiple observation biases.


  ###############    OBSERVABLES         ################################
  # factory functions

  - name: one_way_range # [py]
    short_summary: "Factory function for creating settings for a one-way range observable."
    extended_summary: |
      Factory function for creating observation model settings of one-way range type observables.
      Each combination of observable type and link geometry (link_ends) needs a dedicated :class:`~tudatpy.numerical_simulation.estimation_setup.observation.ObservationModelSettings` object.

    parameters:
      - name: link_ends # [py]
        type: Dict[:class:`~tudatpy.numerical_simulation.estimation_setup.observation.LinkEndType`, Tuple[str, str] # [py]
        description: |
          Set of link ends that define the geometry of the observation. This observable requires the
          `transmitter` and `receiver` :class:`~tudatpy.numerical_simulation.estimation_setup.observation.LinkEndType` entries to be defined.

      - name: light_time_correction_settings # [py]
        type: List[ :class:`LightTimeCorrectionSettings` ], default = list() # [py]
        description: |
          List of corrections for the light-time that are to be used. Default is none, which will result
          in the signal being modelled as moving in a straight line with the speed of light

      - name: bias_settings # [py]
        type: :class:`ObservationBiasSettings`, default = None # [py]
        description: |
          Settings for the observation bias that is to be used for the observation, default is None (unbiased observation)	

    returns:
        type: :class:`ObservationSettings`  # [py]
        description: Instance of the :class:`~tudatpy.numerical_simulation.estimation_setup.observation.ObservationModelSettings` class
          defining the settings for the one-way observable.

  #######################################################################

  - name: n_way_range # [py]
    short_summary: "Factory function for creating settings for a n-way range observable."
    extended_summary: |
      Factory function for creating observation model settings of n-way range type observables.
      Each combination of observable type and link geometry (link_ends) needs a dedicated :class:`~tudatpy.numerical_simulation.estimation_setup.observation.ObservationModelSettings` object.

    parameters:
      - name: one_way_range_settings # [py]
        type: List[ :class:`ObservationModelSettings` ] # [py]
        description: |
          List of observation model settings for each of the n components of the n-way range observable.

      - name: bias_settings # [py]
        type: :class:`ObservationBiasSettings`, default = None # [py]
        description: |
          Settings for the observation bias that is to be used for the observation, default is none (unbiased observation).
          Note that only one bias setting is applied to the n-way observable.

      - name: retransmission_times_function # [py]
        type: Callable[[float], List[float]]], default = None # [py]
        description: |
          Function that provides a list of retransmission delay of each intermediate link end as a function of the observation time at the retransmitting link end.

    returns:
      type: :class:`NWayRangeObservationSettings`  # [py]
      description: Instance of the :class:`~tudatpy.numerical_simulation.estimation_setup.observation.ObservationModelSettings` derived :class:`NWayRangeObservationSettings` class.

  #######################################################################

  - name: one_way_open_loop_doppler # [py]
    short_summary: "Factory function for creating settings for a one-way open-loop Doppler observable."
    extended_summary: |
      Factory function for creating observation model settings of one-way open-loop Doppler type observables.
      The observable is *approximately* equal to
      the range-rate between the link ends, divided by *c*. The full model one-way Doppler observable :math:`h_{D(1),AB}` from 
      link end *A* to link end *B* is computed from: 
    
      .. math::
         h_{D(1),AB}=\frac{d\tau_{A}}{dt_{A}}\frac{t_{A}}{dt_{B}}\frac{dt_{B}}{d\tau_{B}}-1
         
      where :math:`t` and :math:`\tau` denote coordinate and proper time of the transmitter A and receiver B, respectively. The
      resulting observable is non-dimensional (but can be converted to an observed range-rate by multiplying with speed of light :math:`c`)
      This observable represents the 'instantaneous (non-integrated)' Doppler observable, as obtained from open-loop observations.
      It should *not* be used for the modelling of the typical closed-loop observations used in deep space tracking. The coordinate
      time derivative :math:`\frac{t_{A}}{dt_{B}}` is always computed when generating this observable. Settings for the proper time
      rates :math:`\frac{d\tau}{dt}` should be specified by the user through this function.

    parameters:
      - name: link_ends # [py]
        type: Dict[:class:`~tudatpy.numerical_simulation.estimation_setup.observation.LinkEndType`, Tuple[str, str] # [py]
        description: |
          Set of link ends that define the geometry of the observation. This observable requires that the
          `transmitter` and `receiver` :class:`~tudatpy.numerical_simulation.estimation_setup.observation.LinkEndType` entries to be defined.

      - name: light_time_correction_settings # [py]
        type: List[ :class:`LightTimeCorrectionSettings` ], default = list() # [py]
        description: |
          List of corrections for the light-time that are to be used. Default is none, which will result
          in the signal being modelled as moving in a straight line with the speed of light

      - name: bias_settings # [py]
        type: :class:`ObservationBiasSettings`, default = None # [py]
        description: |
          Settings for the observation bias that is to be used for the observation, default is none (unbiased observation)

      - name: transmitter_proper_time_rate_settings # [py]
        type: :class:`DopplerProperTimeRateSettings`, default = None # [py]
        description: |
          Settings for computing the transmitter proper time rate :math:`\frac{d\tau}{dt}`, default is none (:math:`\frac{d\tau}{dt}=1`)

      - name: receiver_proper_time_rate_settings # [py]
        type: :class:`DopplerProperTimeRateSettings`, default = None # [py]
        description: |
          Settings for computing the receiver proper time rate :math:`\frac{d\tau}{dt}`, default is none (:math:`\frac{d\tau}{dt}=1`)

    returns:
        type: :class:`OneWayDopplerObservationSettings`  # [py]
        description: Instance of the :class:`~tudatpy.numerical_simulation.estimation_setup.observation.ObservationModelSettings` derived :class:`OneWayDopplerObservationSettings` class
          defining the settings for the one-way open doppler observable observable.

  #######################################################################

  - name: two_way_open_loop_doppler_from_one_way_links # [py]
    short_summary: "Factory function for creating settings for a two-way open-loop Doppler observable."
    extended_summary: |
      Factory function for creating observation model settings of two-way open-loop Doppler type observables.
      The observable is *approximately* equal to the two-way range-rate between the link ends, divided by *c*. This model uses two combined one-way open-loop observables,
      defined by the :func:`~tudatpy.numerical_simulation.estimation_setup.observation.one_way_open_loop_doppler` function.  The combined effect
      from two one-way Doppler effects: one from link end :math:`A` to link end  :math:`B`, and one from :math:`B` to :math:`C`, computed as:  
    
      .. math::
         h_{D(2),ABC}=(h_{D(1),AB}+1)(h_{D(1),BC}+1)-1

      The resulting observable is non-dimensional (but can be converted to an observed range-rate by multiplying with speed of light :math:`c`)

    parameters:
      - name: uplink_doppler_settings # [py]
        type: :class:`OneWayDopplerObservationSettings` # [py]
        description: |
          Settings for uplink leg of one-way observable, created using :func:`~tudatpy.numerical_simulation.estimation_setup.observation.one_way_open_loop_doppler`

      - name: downlink_doppler_settings # [py]
        type: :class:`OneWayDopplerObservationSettings` # [py]
        description: |
          Settings for downlink leg of one-way observable, created using :func:`~tudatpy.numerical_simulation.estimation_setup.observation.one_way_open_loop_doppler`

      - name: bias_settings # [py]
        type: :class:`ObservationBiasSettings`, default = None # [py]
        description: |
          Settings for the observation bias that is to be used for the full observation, default is none (unbiased observation). Note that,
          even if no bias is applied to the two-way observable, the constituent one-way observables may still be biased.

    returns:
        type: :class:`TwoWayDopplerObservationSettings`  # [py]
        description: Instance of the :class:`~tudatpy.numerical_simulation.estimation_setup.observation.ObservationModelSettings` derived :class:`TwoWayDopplerObservationSettings` class
          defining the settings for the two-way open doppler observable.

  #######################################################################

  - name: one_way_closed_loop_doppler # [py]
    short_summary: "Factory function for creating settings for a one-way closed-loop Doppler observable."
    extended_summary: |
      Factory function for creating observation model settings of one-way closed-loop Doppler type observables.
      This interface only allows for one constant integration time in the observations model.

    parameters:
      - name: link_ends # [py]
        type: Dict[:class:`~tudatpy.numerical_simulation.estimation_setup.observation.LinkEndType`, Tuple[str, str] # [py]
        description: |
          Set of link ends that define the geometry of the observation. This observable requires that the
          `transmitter` and `receiver` :class:`~tudatpy.numerical_simulation.estimation_setup.observation.LinkEndType` entries to be defined.

      - name: integration_time # [py]
        type: float # [py]
        description: |
          Integration time that is to be used for the observable. NOTE: This setting is to be moved to the :class:`ObservationSimulationSettings` class and
          associated factory functions.

      - name: light_time_correction_settings # [py]
        type: List[ :class:`LightTimeCorrectionSettings` ], default = list() # [py]
        description: |
          List of corrections for the light-time that are to be used. Default is none, which will result
          in the signal being modelled as moving in a straight line with the speed of light

      - name: bias_settings # [py]
        type: :class:`ObservationBiasSettings`, default = None # [py]
        description: |
          Settings for the observation bias that is to be used for the observation, default is none (unbiased observation)

    returns:
        type: :class:`ObservationSettings`  # [py]
        description: Instance of the :class:`~tudatpy.numerical_simulation.estimation_setup.observation.ObservationModelSettings` derived `OneWayDifferencedRangeRateObservationSettings` class
          defining the settings for the one-way closed-loop doppler observable.

  #######################################################################

  - name: one_way_closed_loop_doppler # [py]   # overload
    short_summary: "Factory function for creating settings for a one-way closed-loop Doppler observable."
    extended_summary: |
      Factory function for creating observation model settings of one-way closed-loop Doppler type observables.
      This interface only allows for variable (as a function of observation time) integration times in the observations model.

    parameters:
      - name: link_ends # [py]
        type: Dict[:class:`~tudatpy.numerical_simulation.estimation_setup.observation.LinkEndType`, Tuple[str, str] # [py]
        description: |
          Set of link ends that define the geometry of the observation. This observable requires that the
          `transmitter` and `receiver` :class:`~tudatpy.numerical_simulation.estimation_setup.observation.LinkEndType` entries to be defined.

      - name: integration_time_function # [py]
        type: Callable[float, float] # [py]
        description: |
          Integration time that is to be used for the observable as a function of observation time. NOTE: This setting is to be moved to the :class:`ObservationSimulationSettings` class and
          associated factory functions.

      - name: light_time_correction_settings # [py]
        type: List[ :class:`LightTimeCorrectionSettings` ], default = list() # [py]
        description: |
          List of corrections for the light-time that are to be used. Default is none, which will result
          in the signal being modelled as moving in a straight line with the speed of light

      - name: bias_settings # [py]
        type: :class:`ObservationBiasSettings`, default = None # [py]
        description: |
          Settings for the observation bias that is to be used for the observation, default is none (unbiased observation)

    returns:
      type: :class:`OneWayDifferencedRangeRateObservationSettings`  # [py]
      description: Instance of the :class:`~tudatpy.numerical_simulation.estimation_setup.observation.ObservationModelSettings` derived :class:`OneWayDifferencedRangeRateObservationSettings` class
        defining the settings for the one-way closed-loop doppler observable.

  #######################################################################

  - name: angular_position # [py]
    short_summary: "Factory function for creating settings for an angular position observable."
    extended_summary: |
      Factory function for creating observation model settings of angular position type observables.
      This observable can be used for optical astrometry, VLBI, etc. and
      computes the relative angular position in terms of right ascension :math:`alpha` and declination :math:`delta`

    parameters:
      - name: link_ends # [py]
        type: Dict[:class:`~tudatpy.numerical_simulation.estimation_setup.observation.LinkEndType`, Tuple[str, str] # [py]
        description: |
          Set of link ends that define the geometry of the observation. This observable requires that the
          `transmitter` and `receiver` :class:`~tudatpy.numerical_simulation.estimation_setup.observation.LinkEndType` entries to be defined.

      - name: light_time_correction_settings # [py]
        type: List[ :class:`LightTimeCorrectionSettings` ], default = list() # [py]
        description: |
          List of corrections for the light-time that are to be used. Default is none, which will result
          in the signal being modelled as moving in a straight line with the speed of light

      - name: bias_settings # [py]
        type: :class:`ObservationBiasSettings`, default = None # [py]
        description: |
          Settings for the observation bias that is to be used for the observation, default is none (unbiased observation)

    returns:
        type: :class:`ObservationSettings`  # [py]
        description: Instance of the :class:`~tudatpy.numerical_simulation.estimation_setup.observation.ObservationModelSettings` class
          defining the settings for the angular position observable.

  #######################################################################

  - name: cartesian_position # [py]
    short_summary: "Factory function for creating settings for a Cartesian position observable."
    extended_summary: |
      Factory function for creating observation model settings of Cartesian position type observables.
      Note that this observable is typically not realized in reality, but can be very useful for verification or analysis purposes.
      This observable provides the inertial (w.r.t. global frame origin) Cartesian position of the `observed_body` defined by the `link_ends` input.
      The observable has size 3, and contains the :math:`x`, :math:`y` and :math:`z` position

    parameters:
      - name: link_ends # [py]
        type: Dict[:class:`~tudatpy.numerical_simulation.estimation_setup.observation.LinkEndType`, Tuple[str, str] # [py]
        description: |
          Set of link ends that define the geometry of the observation. This observable requires that the
          `observed_body`` :class:`~tudatpy.numerical_simulation.estimation_setup.observation.LinkEndType` entries to be defined.

      - name: bias_settings # [py]
        type: :class:`ObservationBiasSettings`, default = None # [py]
        description: |
          Settings for the observation bias that is to be used for the observation, default is none (unbiased observation)	

    returns:
        type: :class:`ObservationSettings`  # [py]
        description: Instance of the :class:`~tudatpy.numerical_simulation.estimation_setup.observation.ObservationModelSettings` class
          defining the settings for the cartesian position observable.

  #######################################################################

  - name: cartesian_velocity # [py]
    short_summary: "Factory function for creating settings for a Cartesian velocity observable."
    extended_summary: |
      Factory function for creating observation model settings of Cartesian position type observables.
      Note that this observable is typically not realized in reality, but can be very useful for verification or analysis purposes.
      This observable provides the inertial (w.r.t. global frame origin) Cartesian velocity of the `observed_body` defined by the `link_ends` input.
      The observable has size 3, and contains the :math:`x`, :math:`y` and :math:`z` velocity

    parameters:
      - name: link_ends # [py]
        type: Dict[:class:`~tudatpy.numerical_simulation.estimation_setup.observation.LinkEndType`, Tuple[str, str] # [py]
        description: |
          Set of link ends that define the geometry of the observation. This observable requires that the
          `observed_body`` :class:`~tudatpy.numerical_simulation.estimation_setup.observation.LinkEndType` entries to be defined.

      - name: bias_settings # [py]
        type: :class:`ObservationBiasSettings`, default = None # [py]
        description: |
          Settings for the observation bias that is to be used for the observation, default is none (unbiased observation)	

    returns:
        type: :class:`ObservationSettings`  # [py]
        description: Instance of the :class:`~tudatpy.numerical_simulation.estimation_setup.observation.ObservationModelSettings` class
          defining the settings for the cartesian velocity observable.

  #######################################################################

  - name: 313_euler_angles # [py]
    short_summary: "Factory function for creating settings for observable containing the body orientation as Euler angles."
    extended_summary: |
      Factory function for creating observation model settings of Euler angle type observables.
      This observable can be used for *e.g.* body attitude observations, but can also be very useful as 'synthetic' observable for verification or analysis purposes.
      This observable provides the rotation from inertial (defined by the global frame orientation) to body-fixed orientation of the 
      body specified by the `observed_body` in the `link_ends` input.  The observable
      has size 3, and contains the  3-1-3 (e.g. z-x-z) Euler angles

    parameters:
      - name: link_ends # [py]
        type: Dict[:class:`~tudatpy.numerical_simulation.estimation_setup.observation.LinkEndType`, Tuple[str, str] # [py]
        description: |
          Set of link ends that define the geometry of the observation. This observable requires that the
          `observed_body`` :class:`~tudatpy.numerical_simulation.estimation_setup.observation.LinkEndType` entries to be defined.

      - name: bias_settings # [py]
        type: :class:`ObservationBiasSettings`, default = None # [py]
        description: |
          Settings for the observation bias that is to be used for the observation, default is none (unbiased observation)	

    returns:
        type: :class:`ObservationSettings`  # [py]
        description: Instance of the :class:`~tudatpy.numerical_simulation.estimation_setup.observation.ObservationModelSettings` class
          defining the settings for the Euler angle observable.


  ###############         VIABILITY 		 ################################
  # factory functions

  - name: elevation_angle_viability # [py]
    short_summary: "Factory function for defining single elevation angle viability setting."
    extended_summary: |
      Factory function for defining elevation angle viability settings for single link end.
      When simulating observations, this setting ensures that any applicable observations, for which the local elevation angle at link end is less than some limit value, will be omitted.

    parameters:

      - name: link_end_id # [py]
        type: Tuple[str,str] # [py]
        description: |
          Link end (as defined by body/reference point pair, see TODO), for which the elevation angle viability setting is to be created.
          To apply these settings to *all* ground station on a given body (such as "Earth"), use ["Earth", ""].

      - name: elevation_angle # [py]
        type: float
        description: |
          Limit elevation angle, below which no observations are produced when using the :func:`~tudatpy.numerical_simulation.estimation_setup.observation.simulate_observations` function. Note: this
          value must be in radians.
     
    returns:
        type: :class:`ObservationViabilitySettings`  # [py]
        description: Instance of the :class:`~tudatpy.numerical_simulation.estimation_setup.observation.ObservationViabilitySettings` class, defining the settings for observation viability

  #######################################################################

  - name: elevation_angle_viability_list # [py]
    short_summary: "Factory function for defining list of elevation angle viability settings."
    extended_summary: |
      Factory function for defining elevation angle viability settings for multiple link ends.
      Each entry in the returned list contains the observation viability settings for one link end.
      When simulating observations, these settings ensure that any applicable observations, for which the local elevation angle at a link end is less than some limit value, will be omitted.

    parameters:

      - name: link_end_ids # [py]
        type: List[ Tuple[str,str] ] # [py]
        description: |
          List of individual link ends (as defined by body/reference point pair, see TODO), for which the elevation angle viability setting is to be created.
          To apply these settings to *all* ground station on a given body (such as "Earth"), use ["Earth", ""].
          For each link end included in this list, it will be checked if a signal received by and/or transmitted (or reflected) by this
          link end violates the minimum elevation angle constraint.

      - name: elevation_angle # [py]
        type: float
        description: |
          Limit elevation angle, below which no observations are produced when using the :func:`~tudatpy.numerical_simulation.estimation_setup.observation.simulate_observations` function. Note: this
          value must be in radians.

    returns:
      type: :class:`ObservationViabilitySettings`  # [py]
      description: List of :class:`~tudatpy.numerical_simulation.estimation_setup.observation.ObservationViabilitySettings` objects, each
        defining the settings for observation viability of one link end.

  #######################################################################

  - name: body_avoidance_viability # [py]
    short_summary: "Factory function for defining body avoidance observation viability settings."
    extended_summary: |
      Factory function for defining body avoidance observation viability settings for single link ends.
      When simulating observations, this settings ensures that any applicable observations, for which the signal path passes 'too close' to a body, will be omitted.
      The definition of 'too close' is computed as the angle between:
      
      * The line-of-sight vector from a link end to a given third body
      * The line-of-sight between two link ends 

      This constraint is typically used to prevent the Sun from being too close to the field-of-view of the telescope(s), as defined by
      a so-called 'SPE' (Sun-Probe-Earth) angle constraint. The present viability setting generalizes this constraint.

    parameters:

      - name: link_end_id # [py]
        type: Tuple[str,str] # [py]
        description: |
          Link end (as defined by body/reference point pair, see TODO), for which the viability settings are to be created.
          To apply these settings to *all* ground station on a given body (such as "Earth"), use ["Earth", ""] is entry in this list.
          For each link end included in this list, it will be checked if a signal received by and/or transmitted (or reflected) by this
          link end passes too close to the specified body.

      - name: body_to_avoid # [py]
        type: str  # [py]
        description: |
          Name of the body which the signal path should not pass 'too close' to.

      - name: avoidance_angle # [py]
        type: float  # [py]
        description: |
          Limit angle (generalization of SPE angle), below which no observations are produced when using the :func:`~tudatpy.numerical_simulation.estimation_setup.observation.simulate_observations` function. Note: this
          value must be in radians.
     
    returns:
        type: :class:`ObservationViabilitySettings`  # [py]
        description: Instance of the :class:`~tudatpy.numerical_simulation.estimation_setup.observation.ObservationViabilitySettings`, defining the settings for observation viability.

  #######################################################################

  - name: body_avoidance_viability_list # [py]
    short_summary: "Factory function for defining list of body avoidance viability settings."
    extended_summary: |
      Factory function for defining body avoidance viability settings for multiple link ends.
      Each entry in the returned list contains the observation viability settings for one link end.
      When simulating observations, these settings ensure that any applicable observations, for which the signal path passes 'too close' to a body, will be omitted.
      The definition of 'too close' is computed as the angle between:

      * The line-of-sight vector from a link end to a given third body
      * The line-of-sight between two link ends

      This constraint is typically used to prevent the Sun from being too close to the field-of-view of the telescope(s), as defined by
      a so-called 'SPE' (Sun-Probe-Earth) angle constraint. The present viability setting generalizes this constraint.

    parameters:

      - name: link_end_ids # [py]
        type: List[ Tuple[str,str] ]# [py]
        description: |
          List of individual link ends (as defined by body/reference point pair, see TODO), for which the elevation angle viability setting is to be created.
          To apply these settings to *all* ground station on a given body (such as "Earth"), use ["Earth", ""].

      - name: body_to_avoid # [py]
        type: str  # [py]
        description: |
          Name of the body which the signal path should not pass 'too close' to.

      - name: avoidance_angle # [py]
        type: float  # [py]
        description: |
          Limit angle (generalization of SPE angle), below which no observations are produced when using the :func:`~tudatpy.numerical_simulation.estimation_setup.observation.simulate_observations` function. Note: this
          value must be in radians.

    returns:
      type: :class:`ObservationViabilitySettings`  # [py]
      description: List of :class:`~tudatpy.numerical_simulation.estimation_setup.observation.ObservationViabilitySettings` objects, each
        defining the settings for observation viability of one link end.

  #######################################################################

  - name: body_occultation_viability # [py]
    short_summary: "Factory function for defining body occultation viability settings."
    extended_summary: |
      Factory function for defining body occultation viability settings for single link ends.
      When simulating observations, this setting ensures that any applicable observations, for which the signal path is occulted by a given body, will be omitted.
      The occultation is computed using the shape model of the specified body.

    parameters:

      - name: link_end_id # [py]
        type: Tuple[str,str] # [py]
        description: |
          Link end (as defined by body/reference point pair, see TODO), for which the viability settings are to be created.
          To apply these settings to *all* ground station on a given body (such as "Earth"), use ["Earth", ""] is entry in this list.

      - name: body_to_avoid # [py]
        type: str  # [py]
        description: |
          Name of the body which the signal path should not be occulted by.

    returns:
      type: :class:`ObservationViabilitySettings`  # [py]
      description: Instance of the :class:`~tudatpy.numerical_simulation.estimation_setup.observation.ObservationViabilitySettings`, defining the settings for observation viability.

  #######################################################################

  - name: body_occultation_viability_list # [py]
    short_summary: "Factory function for defining body occultation viability settings."
    extended_summary: |
      Factory function for defining body occultation viability settings for multiple link ends.
      Each entry in the returned list contains the observation viability settings for one link end.
      When simulating observations, these settings ensure that any applicable observations, for which the signal path is occulted by a given body, will be omitted.
      The occultation is computed using the shape model of the specified body.

    parameters:

      - name: link_end_ids # [py]
        type: List[ Tuple[str,str] ] # [py]
        description: |
          List of individual link ends (as defined by body/reference point pair, see TODO), for which the viability settings are to be created.
          To apply these settings to *all* ground station on a given body (such as "Earth"), use ["Earth", ""] is entry in this list.
          For each link end included in this list, it will be checked if a signal received by and/or transmitted (or reflected) by this
          link end is occulted by the specified body.

      - name: body_to_avoid # [py]
        type: str  # [py]
        description: |
          Name of the body which the signal path should not be occulted by.

    returns:
        type: :class:`ObservationViabilitySettings`  # [py]
        description: List of :class:`~tudatpy.numerical_simulation.estimation_setup.observation.ObservationViabilitySettings` objects, each
          defining the settings for observation viability of one link end.


  ############## SIMULATION SETTINGS   ########################### (%! here)
  # factory functions

  - name: tabulated_simulation_settings # [py]

    short_summary: "Factory function for creating settings object for observation simulation."
    extended_summary: |
      Factory function for creating single simulation settings object.
      For more information about the characteristics of the resulting settings object, please refer to the description of the :class:`~tudatpy.numerical_simulation.estimation_setup.observation.TabulatedObservationSimulationSettings` class.

    parameters:
      - name: observable_type # [py]
        type: :class:`ObservableType` # [py]
        description: Observable type of which observations are to be simulated.

      - name: link_ends # [py]
        type: Dict[:class:`~tudatpy.numerical_simulation.estimation_setup.observation.LinkEndType`, Tuple[str, str] # [py]
        description: Link ends for which observations are to be simulated.

      - name: simulation_times # [py]
        type: List[float] # [py]
        description: List of times at which to perform the observation simulation.

      - name: reference_link_end_type # [py]
        type: :class:`LinkEndType`, default = :class:`LinkEndType`.receiver # [py]
        description: Defines the link end (via the :class:`LinkEndType`) which is used as a reference for observation times.

      - name: viability_settings # [py]
        type: List[ :class:`ObservationViabilitySettings` ], default = [ ] # [py]
        description: |
          Settings for the creation of the viability criteria calculators, which conduct viability checks on the simulated observations.

      - name: noise_function # [py]
        type: Callable[ [float], numpy.ndarray[numpy.float64[m, 1]] ], default = None # [py]
        description: Function providing the observation noise factors as a function of observation time.

    returns:
      type: :class:`TabulatedObservationSimulationSettings`  # [py]
      description: Instance of the :class:`~tudatpy.numerical_simulation.estimation_setup.observation.ObservationSimulationSettings` derived :class:`~tudatpy.numerical_simulation.estimation_setup.observation.TabulatedObservationSimulationSettings` class.

  #######################################################################

  - name: tabulated_simulation_settings_list # [py] (%! name is not informative, in relation to simple tabulated_simulation_settings)

    short_summary: "Factory function for creating multiple settings object, each defining observation simulation times."
    extended_summary: |
      Factory function for creating multiple observation simulation settings objects in a list.
      During a single call to this function, one simulation settings object is created for each combination of observable type and link geometry given by the `link_ends_per_observable` parameter.
      All resulting simulation settings objects are created considering the same tabulated simulation times ( given by the `simulation_times` parameter), reference link end (`reference_link_end_type`) and viability criteria `viability_settings`.
      For more information about the characteristics of the resulting settings objects, please refer to the description of the :class:`~tudatpy.numerical_simulation.estimation_setup.observation.TabulatedObservationSimulationSettings` class.

      Note that this interface does not allow noise functions to be considered during creation of the simulation settings object.
      For adding noise functions, please use the :func:`~tudatpy.numerical_simulation.estimation_setup.observation.add_gaussian_noise_to_settings` function.

    parameters:
      - name: link_ends_per_observable # [py]
        type: Dict[:class:`ObservableType`, List[Dict[:class:`~tudatpy.numerical_simulation.estimation_setup.observation.LinkEndType`, Tuple[str, str]]]]  # [py]
        description: Link geometry per observable type of which observations are to be simulated.

      - name: simulation_times # [py]
        type: List[ float ] # [py]
        description: List of times at which to perform the observation simulation.

      - name: reference_link_end_type # [py]
        type: :class:`LinkEndType`, default = LinkEndType.receiver # [py]
        description: |
          Defines the link end (via the :class:`LinkEndType`) which is used as a reference for observation times.
          The single link end specified here will be considered as the reference link end for all simulation settings object created in the function call.

      - name: viability_settings # [py]
        type: List[ :class:`ObservationViabilitySettings` ], default = [ ] # [py]
        description: |
          Settings for the creation of the viability criteria calculators, which conduct viability checks on the simulated observations.
          The single settings list given here will be considered as potential viability settings for all simulation settings object created in the function call.


    returns:
      type: List[ TabulatedObservationSimulationSettings ] # [py]
      description: List of :class:`~tudatpy.numerical_simulation.estimation_setup.observation.ObservationSimulationSettings` derived :class:`~tudatpy.numerical_simulation.estimation_setup.observation.TabulatedObservationSimulationSettings` objects.


  ############## ADDING TO SIMULATION SETTINGS   ###########################
  # module functions

  - name: add_gaussian_noise_to_settings # [py]
    short_summary: "Function for adding gaussian noise function to existing observation simulation settings."
    extended_summary: |
      Function for including simple time-independent and time-uncorrelated Gaussian noise function to the simulation settings of one or more observable(s).
      Out of the given :class:`~tudatpy.numerical_simulation.estimation_setup.observation.ObservationSimulationSettings` object(s) in the `observation_simulation_settings` parameter, the modification is only applied to the ones
      which match the :class:`~tudatpy.numerical_simulation.estimation_setup.observation.ObservableType` given by the `observable_type` parameter.
      Note that the :class:`~tudatpy.numerical_simulation.estimation_setup.observation.ObservationSimulationSettings` objects are modified in-place and thus the function does not return anything.

    parameters:
      - name: observation_simulation_settings # [py]
        type: List[ :class:`~tudatpy.numerical_simulation.estimation_setup.observation.ObservationSimulationSettings` ]
        description: Observation simulation settings, given by a list of one or more existing :class:`~tudatpy.numerical_simulation.estimation_setup.observation.ObservationSimulationSettings` objects.

      - name: noise_amplitude # [py]
        type: float # [py]
        description: Standard deviation defining the un-biased Gaussian distribution for the noise.

      - name: observable_type # [py]
        type: :class:`~tudatpy.numerical_simulation.estimation_setup.observation.ObservableType` # [py]
        description: |
          Identifies the observable type in the observation simulation settings to which the noise is to be added.

    returns:
      type: None  # [py]
      description: |
        The :class:`~tudatpy.numerical_simulation.estimation_setup.observation.ObservationSimulationSettings` object(s) are changed in-place.

  #######################################################################

  - name: add_viability_check_to_settings # [py]
    short_summary: "Function for including viability checks into existing observation simulation settings."
    extended_summary: |
      Function for including viability checks into the simulation settings of one or more observable(s).
      Modifications are applied to all given :class:`~tudatpy.numerical_simulation.estimation_setup.observation.ObservationSimulationSettings` object(s),
      matching each :class:`~tudatpy.numerical_simulation.estimation_setup.observation.ObservationSimulationSettings` object with the corresponding :class:`~tudatpy.numerical_simulation.estimation_setup.observation.ObservationViabilitySettings` entry in the `viability_settings` parameter.
      Note that the :class:`~tudatpy.numerical_simulation.estimation_setup.observation.ObservationSimulationSettings` objects are modified in-place and thus the function does not return anything.

    parameters:
      - name: observation_simulation_settings # [py]
        type: List[ :class:`~tudatpy.numerical_simulation.estimation_setup.observation.ObservationSimulationSettings` ]
        description: Observation simulation settings, given by a list of one or more existing :class:`~tudatpy.numerical_simulation.estimation_setup.observation.ObservationSimulationSettings` objects.

      - name: viability_settings # [py]
        type: List[ :class:`~tudatpy.numerical_simulation.estimation_setup.observation.ObservationViabilitySettings` ] # [py]
        description: |
          List of one or more :class:`~tudatpy.numerical_simulation.estimation_setup.observation.ObservationViabilitySettings` objects, defining the viability checks to be included.

    returns:
      type: None  # [py]
      description: |
        The :class:`~tudatpy.numerical_simulation.estimation_setup.observation.ObservationSimulationSettings` object(s) are changed in-place.

  #######################################################################

  - name: add_viability_check_to_settings # [py]
    short_summary: "Function for including viability checks into existing observation simulation settings."
    extended_summary: |
      Function for including viability checks into the simulation settings of one or more observable(s).
      Each of the given :class:`~tudatpy.numerical_simulation.estimation_setup.observation.ObservationSimulationSettings` objects is matched with the corresponding :class:`~tudatpy.numerical_simulation.estimation_setup.observation.ObservationViabilitySettings` entry in the `viability_settings` parameter,
      but *modifications are only applied* to those :class:`~tudatpy.numerical_simulation.estimation_setup.observation.ObservationSimulationSettings` which match the :class:`~tudatpy.numerical_simulation.estimation_setup.observation.ObservableType` given by the `observable_type` parameter.
      Note that the :class:`~tudatpy.numerical_simulation.estimation_setup.observation.ObservationSimulationSettings` objects are modified in-place and thus the function does not return anything.

    parameters:
      - name: observation_simulation_settings # [py]
        type: List[ :class:`~tudatpy.numerical_simulation.estimation_setup.observation.ObservationSimulationSettings` ]
        description: Observation simulation settings, given by a list of one or more existing :class:`~tudatpy.numerical_simulation.estimation_setup.observation.ObservationSimulationSettings` objects.

      - name: viability_settings # [py]
        type: List[ :class:`~tudatpy.numerical_simulation.estimation_setup.observation.ObservationViabilitySettings` ] # [py]
        description: |
          List of one or more :class:`~tudatpy.numerical_simulation.estimation_setup.observation.ObservationViabilitySettings` objects, defining the viability checks to be included.

      - name: observable_type # [py]
        type: :class:`ObservableType` # [py]
        description: |
          Identifies the observable type in the observation simulation settings for which the viability checks are to be considered.

    returns:
      type: None  # [py]
      description: |
        The :class:`~tudatpy.numerical_simulation.estimation_setup.observation.ObservationSimulationSettings` object(s) are changed in-place.

  #######################################################################

  - name: add_dependent_variables_to_settings # [py]
    short_summary: "Function for including dependent variables into existing observation simulation settings."
    extended_summary: |

      Function for including the computation and reporting of dependent variables into the observation simulation settings of one or more observable(s).
      Note: The associated functionality is not yet mature enough for the end user. Function is exposed for development purposes only.

  #   Modifications are applied to all given :class:`~tudatpy.numerical_simulation.estimation_setup.observation.ObservationSimulationSettings` object(s),
  #   matching each :class:`~tudatpy.numerical_simulation.estimation_setup.observation.ObservationSimulationSettings` object with the corresponding :class:`ObservationDependentVariableSettings` entry in the `dependent_variable_settings` parameter.
  #   Note that the :class:`~tudatpy.numerical_simulation.estimation_setup.observation.ObservationSimulationSettings` objects are modified in-place and thus the function does not return anything.

  # parameters:
  #   - name: observation_simulation_settings # [py]
  #     type: List[ :class:`~tudatpy.numerical_simulation.estimation_setup.observation.ObservationSimulationSettings` ]
  #     description: Observation simulation settings, given by a list of one or more existing :class:`~tudatpy.numerical_simulation.estimation_setup.observation.ObservationSimulationSettings` objects.

  #   - name: dependent_variable_settings # [py]
  #     type: List[ :class:`~tudatpy.numerical_simulation.estimation_setup.observation.ObservationDependentVariableSettings` ] # [py]
  #     description: |
  #       List of one or more :class:`~tudatpy.numerical_simulation.estimation_setup.observation.ObservationDependentVariableSettings` objects, defining the dependent variables to be considered.

  #   - name: bodies # [py]
  #     type: :class:`~tudatpy.numerical_simulation.environment_setup.SystemOfBodies` # [py]
  #     description: |
  #       Object consolidating all bodies and environment models that constitute the physical environment.

  # returns:
  #   type: None  # [py]
  #   description: |
  #     The :class:`~tudatpy.numerical_simulation.estimation_setup.observation.ObservationSimulationSettings` object(s) are changed in-place.
