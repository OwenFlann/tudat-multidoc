extended_summary: |
  This module provides the functionality for creating propagator settings.

# The structure of this file follows the order of expose_propagator_setup.cpp (tudatpy) and
# includes content for nBodyStateDerivative.h, bulirschStoerVariableStepsizeIntegrator.h,
# propagationSettings.h, propagationTerminationSettings.h (tudat)


references: |
  .. [1] Vittaldev, V., Mooij, E., & Naeije, M. C. (2012). Unified State Model theory and
         application in Astrodynamics. Celestial Mechanics and Dynamical Astronomy, 112(3), 253-282.
  .. [2] Wakker, K. F. (2015). Fundamentals of astrodynamics.
  .. [3] Hintz, G. R. (2008). Survey of orbit element sets. Journal of guidance, control, and dynamics, 31(3), 785-790.
  .. [4] Vallado, D. A. (2001). Fundamentals of astrodynamics and applications (Vol. 12). Springer Science & Business Media.


enums:

  #       py::enum_<tp::TranslationalPropagatorType>
  #        enum tudat::propagators::TranslationalPropagatorType

  - name: TranslationalPropagatorType
    short_summary: "Enumeration of available translational propagator types."
    #extended_summary: |
      #Enumeration of translational propagator types supported by tudat.
    members:
      - name: undefined_translational_propagator
      - name: cowell
        description: "Propagation of Cartesian elements (state vector size 6), without any transformations"
      - name: encke
        description: "Propagation of the difference in Cartesian elements of the orbit w.r.t. an unperturbed reference orbit.
          The reference orbit is generated from the initial state/central body, and not updated during the propagation
          (see Wakker, 2015 [2]_)"
      - name: gauss_keplerian
        description: "Propagation of Keplerian elements (state vector size 6), with true anomaly as the 'fast' element  (see Vallado, 2001 [4]_)"
      - name: gauss_modified_equinoctial
        description: "Propagation of Modified equinoctial elements (state vector size 6), with the element :math:`I` defining
          the location of the singularity based on the initial condition (see Hintz, 2008 [3]_)"
      - name: unified_state_model_quaternions
        description: "Propagation of Unified state model using quaternions (state vector size 7, see Vittaldev et al., 2012 [1]_)"
      - name: unified_state_model_modified_rodrigues_parameters
        description: "Propagation of Unified state model using modified Rodrigues parameters (state vector size 7, last element represents shadow parameter, see Vittaldev et al., 2012 [1]_)"
      - name: unified_state_model_exponential_map
        description: "Propagation of Unified state model using exponential map (state vector size 7, last element represents shadow parameter, see Vittaldev et al., 2012 [1]_)"


  - name: RotationalPropagatorType
    short_summary: "Enumeration of available rotational propagator types."
    #extended_summary: |
      #Enumeration of rotational propagator types supported by tudat.
    members:
      - name: undefined_rotational_propagator
      - name: quaternions
        description: "Entries 1-4: The quaternion defining the rotation from inertial to body-fixed frame
          (see `here <https://tudat-space.readthedocs.io/en/latest/_src_user_guide/state_propagation/environment_setup/use_of_reference_frames.html#definition-of-rotational-state>`_)
          Entries 5-7: The body's angular velocity vector, expressed in its body-fixed frame."
      - name: modified_rodrigues_parameters
        description: "Entries 1-4: The modified Rodrigues parameters defining the
          rotation from inertial to body-fixed frame (with entry four the shadow parameter)
          Entries 5-7: The body's angular velocity vector, expressed in its body-fixed frame."
      - name: exponential_map
        description: "Entries 1-4: The exponential map defining the
          rotation from inertial to body-fixed frame (with entry four the shadow parameter)
          Entries 5-7: The body's angular velocity vector, expressed in its body-fixed frame."

  - name: IntegratedStateType # [cpp]
  - name: StateType # [py]
    short_summary: "Enumeration of available integrated state types."
#    extended_summary: |
#      Enumeration of integrated state types supported by tudat.

    members:

      - name: hybrid  # [cpp]
      - name: translational_state # [cpp]
      - name: rotational_state # [cpp]
      - name: body_mass_state # [cpp]
      - name: custom_state # [cpp]

      - name: hybrid_type # [py]
      - name: translational_type # [py]
      - name: rotational_type # [py]
      - name: body_mass_type # [py]
      - name: custom_type # [py]


  #   enum tudatpy.simulation.propagation_setup.propagator.PropagationTerminationTypes # python only(?)

  - name: PropagationTerminationTypes # [py]
    short_summary: "Enumeration of possible propagation termination types"
    #extended_summary: | # [py]
      #Enumeration of rotational propagator types supported by tudat. # [py]

    members:
      - name: time_stopping_condition # [py]
      - name: cpu_time_stopping_condition # [py]
      - name: dependent_variable_stopping_condition # [py]
      - name: hybrid_stopping_condition # [py]
      - name: custom_stopping_condition # [py]

  ######


classes:

  # base: dependent variables
  - name: DependentVariableSaveSettings
    short_summary: "Functional class to define settings for dependent variable to save."
#    extended_summary: |
#      Class to define settings for dependent variable to save.

    methods:
      - name: ctor
        short_summary: "Constructor."
        extended_summary: |
          Instances of this class are typically not generated by the user because this is a base class.


  # base: propagator
  - name: PropagatorSettings
    short_summary: "Functional base class to define settings for propagators."
    extended_summary: |
      Base class to define settings for propagators. Derived classes are split into settings for single- and multi-arc dynamics.

    methods:
      - name: ctor
        short_summary: "Constructor."
        extended_summary: |
          Instances of this class are typically not generated by the user because this is a base class.

      - name: resetInitialStates # [cpp]
      - name: reset_initial_states # [py]
        short_summary: "Function to reset the initial state used as input for numerical integration."
#        extended_summary: |
#          Function to reset the initial state used as input for numerical integration.
        parameters:
        - name: initialBodyStates # [cpp]
          type: Eigen::Matrix # [cpp]
        - name: initial_states # [py]
          type: numpy.ndarray # [py]
          description: Initial states to be reset for the numerical propagation.


  # derived: propagator (1)
  - name: MultiArcPropagatorSettings
    short_summary: "`PropagatorSettings`-derived class to define settings for multi-arc dynamics."
#    extended_summary: |
#       `PropagatorSettings`-derived class to define settings for multi-arc dynamics.

    methods:
      - name: ctor
        short_summary: "Constructor."
        extended_summary: |
          Instances of this class are typically not generated by the user. Settings objects for integrators should be
          instantiated through the factory functions of a derived class.


  # derived: propagator (2)
  - name: HybridArcPropagatorSettings
    short_summary: "`PropagatorSettings`-derived class to define settings for hybrid-arc dynamics."
#    extended_summary: |
#       `PropagatorSettings`-derived class to define settings for hybrid-arc dynamics.

    methods:
      - name: ctor
        short_summary: "Constructor."
        extended_summary: |
          Instances of this class are typically not generated by the user. Settings objects for integrators should be
          instantiated through the factory functions of a derived class.


  # derived: propagator (3)
  - name: SingleArcPropagatorSettings
    short_summary: "`PropagatorSettings`-derived class to define settings for single-arc dynamics."
#    extended_summary: |
#       `PropagatorSettings`-derived class to define settings for single-arc dynamics.

    attributes:
    - name: terminationSettings_ # [cpp]
      type: PropagationTerminationSettings # [cpp]
    - name: termination_settings # [py]
      type: PropagationTerminationSettings # [py]
      description: Settings for creating the object that checks whether the propagation is finished.

    methods:
      - name: ctor
        short_summary: "Constructor."
        extended_summary: |
          Instances of this class are typically not generated by the user. Settings objects for integrators should be
          instantiated through the factory functions of a derived class.

  # derived, level 2: translational propagator
  - name: TranslationalStatePropagatorSettings
    short_summary: "`SingleArcPropagatorSettings`-derived class to define settings for single-arc translational dynamics."
#    extended_summary: |
#       `SingleArcPropagatorSettings`-derived class to define settings for single-arc translational dynamics.

    attributes:
    - name: accelerationSettingsMap_ # [cpp] readonly
      type: SelectedAccelerationMap # [cpp] readonly
    - name: acceleration_settings # [py] readonly
      type: SelectedAccelerationMap # [py] readonly
      description: Settings for retrieving the accelerations acting on the body during propagation.

    methods:
      - name: ctor
        short_summary: "Constructor."
        extended_summary: |
          Instances of this class are typically not generated by the user. Settings objects for integrators should be
          instantiated through the factory functions of a derived class.

      - name: resetInitialStates # [cpp]
      - name: reset_initial_states # [py]
        short_summary: "Function to reset the initial state used as input for numerical integration."
#        extended_summary: |
#          Function to reset the initial state used as input for numerical integration.
        parameters:
        - name: initialBodyStates # [cpp]
          type: Eigen::Matrix # [cpp]
        - name: initial_states # [py]
          type: numpy.ndarray # [py]
          description: Initial states to be reset for the numerical propagation.

      - name: resetIntegratedStateModels # [cpp]
      - name: recreate_state_derivative_models # [py]
        short_summary: "Function to (re)create the integrated state models (e.g. acceleration/torque/mass models)."
        extended_summary: |
          Function to create the integrated state models (e.g. acceleration/torque/mass models) for
          each fo the propagators state types contained in `propagatorSettingsMap_`.
        parameters:
        - name: bodies # [cpp]
          type: SystemOfBodies # [cpp]
        - name: bodies # [py]
          type: SystemOfBodies # [py]
          description: System of bodies used in the propagation.

      - name: getSingleTypePropagatorSettings # [cpp]
      - name: single_type_settings # [py]
        short_summary: "Function to retrieve a single type of propagator."
        extended_summary: |
          Function to retrieve a single type of propagator (translational, rotational or mass). This function is
          often used in multi-type propagation.
        parameters:
        - name: stateType # [cpp]
          type: IntegratedStateType # [cpp]
        - name: state_type # [py]
          type: IntegratedStateType # [py]
          description: State type to be retrieved.


  # derived, level 2: rotational state propagator
  - name: RotationalStatePropagatorSettings
    short_summary: "`SingleArcPropagatorSettings`-derived class to define settings for single-arc rotational state propagation."
#    extended_summary: |
#       `SingleArcPropagatorSettings`-derived class to define settings for single-arc rotational state propagation.

    methods:
      - name: ctor
        short_summary: "Constructor."
        extended_summary: |
          Instances of this class are typically not generated by the user. Settings objects for integrators should be
          instantiated through the factory functions of a derived class.


  # derived, level 2: multitype propagator
  - name: MultiTypePropagatorSettings
    short_summary: "`SingleArcPropagatorSettings`-derived class to define settings for propagation of multiple quantities."
#    extended_summary: |
#       `SingleArcPropagatorSettings`-derived class to define settings for propagation of multiple quantities.

    properties:
    - name: propagator_settings_per_type # [py]
      type: dict[IntegratedStateType, list[SingleArcPropagatorSettings]] # [py]

    methods:
      - name: ctor
        short_summary: "Constructor."
        extended_summary: |
          Instances of this class are typically not generated by the user. Settings objects for integrators should be
          instantiated through the factory functions of a derived class.

      - name: resetInitialStates # [cpp]
      - name: reset_initial_states # [py]
        short_summary: "Function to reset the initial states used as input for numerical integration."
#        extended_summary: |
#          Function to reset the initial states used as input for numerical integration.
        parameters:
        - name: initialBodyStates # [cpp]
          type: Eigen::Matrix # [cpp]
        - name: initial_states # [py]
          type: numpy.ndarray # [py]
          description: Initial states to be reset for the numerical propagation.

      - name: resetIntegratedStateModels # [cpp]
      - name: recreate_state_derivative_models # [py]
        short_summary: "Function to (re)create the integrated state models (e.g. acceleration/torque/mass models)."
        extended_summary: |
          Function to create the integrated state models (e.g. acceleration/torque/mass models) for
          each of the propagators state types contained in `propagatorSettingsMap_`.
        parameters:
        - name: bodies # [cpp]
          type: SystemOfBodies # [cpp]
        - name: bodies # [py]
          type: SystemOfBodies # [py]
          description: System of bodies used in the propagation.

      - name: getSingleTypePropagatorSettings # [cpp]
      - name: single_type_settings # [py]
        short_summary: "Function to retrieve a single type of propagator."
        extended_summary: |
          Function to retrieve a single type of propagator (translational, rotational or mass). This function is
          often used in multi-type propagation.
        parameters:
        - name: stateType # [cpp]
          type: IntegratedStateType # [cpp]
        - name: state_type # [py]
          type: IntegratedStateType # [py]
          description: State type to be retrieved.

      - name: getPropagatorSettingsMap # [cpp]
        short_summary: "Function to retrieve the propagator settings map." # [cpp]
#        extended_summary: "Function to retrieve the propagator settings map." # [cpp]


  # base: termination settings
  - name: PropagationTerminationSettings
    short_summary: "Functional base class to define termination settings for the propagation."
#    extended_summary: |
#       Functional base class to define termination settings for the propagation.

    methods:
      - name: ctor
        short_summary: "Constructor."
        extended_summary: |
          Instances of this class are typically not generated by the user because this is a base class.


  # derived (1): dependent variable termination settings
  - name: PropagationDependentVariableTerminationSettings
    short_summary: "`PropagationTerminationSettings`-derived class to define termination settings for the propagation from dependent variables."
#    extended_summary: |
#       `PropagationTerminationSettings`-derived class to define termination settings for the propagation from dependent variables.

    methods:
      - name: ctor
        short_summary: "Constructor."
        extended_summary: |
          Instances of this class are typically not generated by the user. Settings objects for integrators should be
          instantiated through the factory functions of a derived class.


  # derived (2): time termination settings
  - name: PropagationTimeTerminationSettings
    short_summary: "`PropagationTerminationSettings`-derived class to define termination settings for the propagation from propagation time."
#    extended_summary: |
#       `PropagationTerminationSettings`-derived class to define termination settings for the propagation from propagation time.

    methods:
      - name: ctor
        short_summary: "Constructor."
        extended_summary: |
          Instances of this class are typically not generated by the user. Settings objects for integrators should be
          instantiated through the factory functions of a derived class.


  # derived (3): CPU time termination settings
  - name: PropagationCPUTimeTerminationSettings
    short_summary: "`PropagationTerminationSettings`-derived class to define termination settings for the propagation from CPU time."
#    extended_summary: |
#       `PropagationTerminationSettings`-derived class to define termination settings for the propagation from CPU time.

    methods:
      - name: ctor
        short_summary: "Constructor."
        extended_summary: |
          Instances of this class are typically not generated by the user. Settings objects for integrators should be
          instantiated through the factory functions of a derived class.


  # derived (4): custom termination settings
  - name: PropagationCustomTerminationSettings
    short_summary: "`PropagationTerminationSettings`-derived class to define custom termination settings for the propagation."
#    extended_summary: |
#       `PropagationTerminationSettings`-derived class to define custom termination settings for the propagation.

    methods:
      - name: ctor
        short_summary: "Constructor."
        extended_summary: |
          Instances of this class are typically not generated by the user. Settings objects for integrators should be
          instantiated through the factory functions of a derived class.


  # derived (5): hybrid termination settings
  - name: PropagationHybridTerminationSettings
    short_summary: "`PropagationTerminationSettings`-derived class to define hybrid termination settings for the propagation."
#    extended_summary: |
#       `PropagationTerminationSettings`-derived class to define hybrid termination settings for the propagation.

    methods:
      - name: ctor
        short_summary: "Constructor."
        extended_summary: |
          Instances of this class are typically not generated by the user. Settings objects for integrators should be
          instantiated through the factory functions of a derived class.

########################################

  - name: PropagationPrintSettings
    short_summary: "Class to save settings on what is to be written to the console during the propagation of a single arc."

    methods:
    - name: enable_all_printing
      short_summary: |
        Function enabling all True/False printing (e.g. sets all boolean attributes to True)       
      parameters:
      returns:

    - name: disable_all_printing # [py]
      short_summary: |
        Function enabling all printing (e.g. sets all boolean attributes to False, and disables all other output as well)
      parameters:
      returns:

    attributes:
    - name: print_dependent_variable_indices # [py]
      type: Bool # [py]
      description: |
        Boolean defining whether the meaning and indices of the
        entries of the dependent variable data are to be printed to
        the console (before the propagation).

        .. note:: The same information can be retrieved from the
                  :py:attr:`SingleArcPropagatorResults.dependent_variable_ids`
                  attribute.

    - name: print_state_data # [py]
      type: Bool # [py]
      description: |
        Boolean defining whether the meaning and indices of the
        entries of the state vector are to be printed to
        the console (before the propagation).

        .. note:: The same information can be retrieved from the
                  :py:attr:`SingleArcPropagatorResults.state_ids`
                  attribute.

    - name: print_number_of_function_evaluations # [py]
      type: Bool # [py]
      description: |    # [py]
        Boolean defining whether the number of function evaluations that
        were performed is to be printed to the console (after propagation).

    - name: print_propagation_clock_time # [py]
      type: Bool # [py]
      description: |    # [py]
        Boolean defining whether the total clock time taken for the propagation
        is to be printed to the console (after propagation).

    - name: print_termination_reason # [py]
      type: Bool # [py]
      description: |    # [py]
        Boolean defining whether the reason for propagation termination
        is to be printed to the console (after propagation).

    - name: print_initial_and_final_conditions # [py]
      type: Bool # [py]
      description: |    # [py]
        Boolean defining whether the initial and final conditions (state and time)
        are to be printed to the console (beforee and after propagation, respectively).

    - name: state_print_interval # [py]
      type: Float # [py]
      description: |    # [py]
        Variable indicating how often (in seconds of simulation time)
        the current state and time are to be printed to the console (by default, set to NaN - they are never printed).


########################################

  - name: PropagatorProcessingSettings
    short_summary: "Class to define settings on how the numerical results are to be used, both during the propagation (printing to console) and after propagation (resetting environment)"
    
    attributes:
    - name: clear_numerical_solutions # [py]
      type: Bool
      description: |    # [py]
        Boolean defining whether the propagation results should be
        deleted after the propagation is terminated. If this is
        done, the :py:attr:`~state_history`,
        :py:attr:`~unprocessed_state_history` and
        :py:attr:`~dependent_variable_history` will not be
        accessible. Putting this setting to True (deleting the
        results) is only sensible when the
        :py:attr:`~set_integrated_result` is set to True. In that
        case, the propagated states are *not* accessible directly
        from this objects, but the results are used to update the
        environment, *e.g.* update the ephemeris of the propagated
        body with the numerical results.

    - name: set_integrated_result # [py]
      type: Bool
      description: |  # [py]
        Boolean defining whether the propagation results are to
        be used to update the environment. If this variable is set
        to False, the numerical propagation results can be
        retrieved from this object (provided the
        :py:attr:`~clear_numerical_solutions` is set to False),
        but the (for instance) Ephemeris of the propagated body
        is not updated with the propagation results. If this
        variable is set to True, the properties of the propagated
        :class:`~tudatpy.numerical_simulation.environment.Body`
        object will be updated as per the numerical results
        (see `here <https://docs.tudat.space/en/stable/_src_user_guide/state_propagation/propagation_setup/console_output.html#automatic-processing>`_ for details).

functions:

  # Translational propagator
  - name: translationalStatePropagatorSettings # [cpp]
  - name: translational # [py]
    short_summary: "Factory function to create translational state propagator settings with stopping condition at given final time."
    extended_summary: |
      Factory function to create translational state propagator settings for N bodies.
      The propagated state vector is defined by the combination of integrated bodies, and their central body, the combination
      of which define the relative translational states for which a differential equation is to be solved. The propagator
      input defines the formulation in which the differential equations are set up
      The dynamical models are defined by an ``AccelerationMap``, as created by :func:`~create_acceleration_models` function.


    parameters:
      - name: centralBodies # [cpp]
        type: std::vector<std::string> # [cpp]
      - name: central_bodies # [py]
        type: list[str] # [py]
        description: List of central bodies with respect to which the bodies to be integrated are propagated.

      - name: accelerationsMap # [cpp]
        type: AccelerationMap # [cpp]
      - name: acceleration_models # [py]
        type: AccelerationMap # [py]
        description: Set of accelerations acting on the bodies to propagate, provided as acceleration models.

      - name: bodiesToIntegrate # [cpp]
        type: std::vector<std::string> # [cpp]
      - name: bodies_to_integrate # [py]
        type: list[str] # [py]
        description: List of bodies to be numerically propagated, whose order reflects the order of the central bodies.

      - name: initialBodyStates # [cpp]
        type: Eigen::Matrix # [cpp]
      - name: initial_states # [py]
        type: numpy.ndarray # [py]
        description: Initial states of the bodies to integrate (one initial state for each body, concatenated into a single array), provided in the same order as the
          bodies to integrate. The initial states must be expressed in Cartesian elements, w.r.t. the central body of each integrated body. 
          The states must be defined with the same frame orientation as the global frame orientation of the environment (specified when creating a system of bodies, see for instance
          :func:`~tudatpy.numerical_simulation.environment_setup.get_default_body_settings` and :func:`~tudatpy.numerical_simulation.environment_setup.create_system_of_bodies`).
          Consequently, for N integrated bodies, this input is a vector with size size 6N.

      - name: initial_time # [py]
        type: float # [py]
        description: Initial epoch of the numerical propagation

      - name: integrator_settings # [py]
        type: IntegratorSettings # [py]
        description: |
          Settings defining the numerical integrator that is to be used for the propagation

          .. note:: The sign of the initial time step in the integrator settings defines whether the propagation will be forward or backward in time

      - name: terminationSettings # [cpp]
        type: PropagationTerminationSettings # [cpp]
      - name: termination_settings # [py]
        type: PropagationTerminationSettings # [py]
        description: Generic termination settings object to check whether the propagation should be ended.

      - name: propagator # [cpp]
        type: TranslationalPropagatorType, default=cowell # [cpp]
      - name: propagator # [py]
        type: TranslationalPropagatorType, default=cowell # [py]
        description: Type of translational propagator to be used (see `TranslationalPropagatorType` enum).

      - name: dependentVariablesToSave # [cpp]
        type: std::vector<SingleDependentVariableSaveSettings>, default=std::vector() # [cpp]
      - name: output_variables # [py]
        type: list[SingleDependentVariableSaveSettings], default=[] # [py]
        description: List of dependent variables to be saved (by default, no dependent variables are saved).

      - name: processing_settings # [cpp]
        type: SingleArcPropagatorProcessingSettings, default=SingleArcPropagatorProcessingSettings() # [cpp]	
        description: Class to define settings on how the numerical results are to be used, both during the propagation (printing to console) and after propagation (resetting environment)

    returns:
        type: TranslationalStatePropagatorSettings
        description: Translational state propagator settings object.




  # Rotational propagator (overload 1)
  - name: RotationalStatePropagatorSettings # [cpp]
  - name: rotational # [py]
    short_summary: "Factory function to create rotational state propagator settings."
    extended_summary: |
      Factory function to create rotational state propagator settings for N bodies.
      The propagated state vector is defined by the integrated bodies, which defines the bodies for which the
      differential equation defining the evolution of the rotational state between an
      inertial and body-fixed frame are to be solved. The propagator input defines the
      formulation in which the differential equations are set up. The dynamical models are
      defined by an ``TorqueModelMap``, as created by ``create_torque_models`` function.

    parameters:
      - name: torqueModelMap # [cpp]
        type: TorqueModelMap # [cpp]
      - name: torque_models # [py]
        type: TorqueModelMap # [py]
        description: Set of torques acting on the bodies to propagate, provided as torque models.

      - name: bodiesToIntegrate # [cpp]
        type: std::vector<std::string> # [cpp]
      - name: bodies_to_integrate # [py]
        type: list[str] # [py]
        description: List of bodies to be numerically propagated, whose order reflects the order of the central bodies.

      - name: initialBodyStates # [cpp]
        type: Eigen::Matrix # [cpp]
      - name: initial_states # [py]
        type: numpy.ndarray # [py]
        description: |
          Initial rotational states of the bodies to integrate (one initial state for each body), provided in the same order as the bodies to integrate.
          Regardless of the propagator that is selected, the initial rotational state is always defined as four quaternion entries, and the angular velocity of the body,
          as defined in more detail `here <https://tudat-space.readthedocs.io/en/latest/_src_user_guide/state_propagation/environment_setup/use_of_reference_frames.html#definition-of-rotational-state>`_.

      - name: terminationSettings # [cpp]
        type: PropagationTerminationSettings # [cpp]
      - name: termination_settings # [py]
        type: PropagationTerminationSettings # [py]
        description: Generic termination settings object to check whether the propagation should be ended.

      - name: propagator # [cpp]
        type: RotationalPropagatorType, default=quaternions # [cpp]
      - name: propagator # [py]
        type: RotationalPropagatorType, default=quaternions # [py]
        description: Type of rotational propagator to be used (see `RotationalPropagatorType` enum).

      - name: dependentVariablesToSave # [cpp]
        type: std::vector<SingleDependentVariableSaveSettings>, default=std::vector() # [cpp]
      - name: output_variables # [py]
        type: list[SingleDependentVariableSaveSettings], default=[] # [py]
        description: List of dependent variables to be saved (by default, no dependent variables are saved).

      - name: printInterval # [cpp]
        type: double, default=TUDAT_NAN # [cpp]
      - name: print_interval # [py]
        type: float, default=TUDAT_NAN # [py]
        description: Variable indicating how often (in seconds or in the unit of the independent variable) the current state and time are to be printed to the console (by default, they are never printed).

    returns:
        type: RotationalStatePropagatorSettings
        description: Rotational state propagator settings object.


  # Mass propagator (overload 5)
  - name: massPropagatorSettings # [cpp]
  - name: mass # [py]
    short_summary: "Factory function to create mass propagator settings"
    extended_summary: |
      Factory function to create mass propagator settings 
      It works by providing a key-value mass rate container, containing the list of mass rate settings objects associated to
      each body. In this function, the dependent variables to save are provided
      as a list of SingleDependentVariableSaveSettings objects. In this function, the termination conditions are set
      through the termination settings object provided.

    parameters:
      - name: bodiesWithMassToPropagate # [cpp]
        type: std::vector<std::string> # [cpp]
      - name: bodies_with_mass_to_propagate # [py]
        type: list[str] # [py]
        description: List of bodies whose mass should be numerically propagated.

      - name: massRateSettings # [cpp]
        type: SelectedMassRateModelMap # [cpp]
      - name: mass_rate_settings # [py]
        type: SelectedMassRateModelMap # [py]
        description: Mass rates associated to each body, provided as a mass rate settings object.

      - name: initialBodyMasses # [cpp]
        type: Eigen::Matrix # [cpp]
      - name: initial_body_masses # [py]
        type: numpy.ndarray # [py]
        description: Initial masses of the bodies to integrate (one initial mass for each body), provided in the same order as the bodies to integrate.

      - name: terminationSettings # [cpp]
        type: PropagationTerminationSettings # [cpp]
      - name: termination_settings # [py]
        type: PropagationTerminationSettings # [py]
        description: Generic termination settings object to check whether the propagation should be ended.

      - name: dependentVariablesToSave # [cpp]
        type: std::vector<SingleDependentVariableSaveSettings>, default=std::vector() # [cpp]
      - name: output_variables # [py]
        type: list[SingleDependentVariableSaveSettings], default=[] # [py]
        description: List of dependent variables to be saved (by default, no dependent variables are saved).

      - name: printInterval # [cpp]
        type: double, default=TUDAT_NAN # [cpp]
      - name: print_interval # [py]
        type: float, default=TUDAT_NAN # [py]
        description: Variable indicating how often (in seconds or in the unit of the independent variable) the current state and time are to be printed to the console (by default, they are never printed).

    returns:
        type: MassPropagatorSettings
        description: Mass propagator settings object.


  # Multitype propagator (overload 2)
  - name: multiTypePropagatorSettings # [cpp]
  - name: multitype # [py]
    short_summary: "Factory function to create multitype propagator settings."
    extended_summary: |
      Factory function to create multitype propagator settings.
      It works by providing a list of SingleArcPropagatorSettings objects. When using this function,
      only the termination and output settings provided here are used, any such settings in the
      constituent propagator settings are ignored

      .. note:: The propagated state contains the state types in the following order: Translational ( **C** ), Rotational ( **R** ), Mass ( **M** ), and Custom ( **C** ).
                When propagating two bodies, an example of what the output state would look like is for instance:
                [ **T** Body 1, **T** Body 2, **R** Body 1, **R** Body 2, **M** Body 1, **M** Body 2 ]

    parameters:
      - name: propagatorSettingsVector # [cpp]
        type: std::vector<SingleArcPropagatorSettings> # [cpp]
      - name: propagator_settings_list # [py]
        type: list[SingleArcPropagatorSettings] # [py]
        description: List of SingleArcPropagatorSettings objects to use.

      - name: terminationSettings # [cpp]
        type: PropagationTerminationSettings # [cpp]
      - name: termination_settings # [py]
        type: PropagationTerminationSettings # [py]
        description: Generic termination settings object to check whether the propagation should be ended.

      - name: dependentVariablesToSave # [cpp]
        type: std::vector<SingleDependentVariableSaveSettings>, default=std::vector() # [cpp]
      - name: output_variables # [py]
        type: list[SingleDependentVariableSaveSettings], default=[] # [py]
        description: List of dependent variables to be saved (by default, no dependent variables are saved).

      - name: printInterval # [cpp]
        type: double, default=TUDAT_NAN # [cpp]
      - name: print_interval # [py]
        type: float, default=TUDAT_NAN # [py]
        description: Variable indicating how often (in seconds or in the unit of the independent variable) the current state and time are to be printed to the console (by default, they are never printed).

    returns:
        type: MassPropagatorSettings
        description: Mass propagator settings object.


  # Multiarc propagator
  - name: multiArcPropagatorSettings # [cpp]
  - name: multi_arc # [py]
    short_summary: "Factory function to create multi-arc propagator settings."
    extended_summary: |
      Factory function to create multi-arc propagator settings. It works by providing separate settings for
      each arc in a list.

    parameters:
      - name: singleArcSettings # [cpp]
        type: std::vector<SingleArcPropagatorSettings> # [cpp]
      - name: single_arc_settings # [py]
        type: list[SingleArcPropagatorSettings] # [py]
        description: List of SingleArcPropagatorSettings objects to use, one for each arc.

      - name: transferInitialStateInformationPerArc # [cpp]
        type: bool, default=false # [cpp]
      - name: transfer_state_to_next_arc # [py]
        type: bool, default=False # [py]
        description: It denotes whether whether the initial state of arc N+1 is to be taken from arc N (for N>0).

    returns:
        type: MultiArcPropagatorSettings
        description: Multi-arc propagator settings object.

  # Hybrid arc propagator
  - name: hybridArcPropagatorSettings # [cpp]
  - name: hybrid_arc # [py]
    short_summary: "Factory function to create hybrid-arc propagator settings."
    extended_summary: |
      Factory function to create hybrid-arc propagator settings (i.e., a combination of single- and multi-arc dynamics).

    parameters:
      - name: singleArcSettings # [cpp]
        type: SingleArcPropagatorSettings # [cpp]
      - name: single_arc_settings # [py]
        type: SingleArcPropagatorSettings # [py]
        description: SingleArcPropagatorSettings object to use for the propagation.

      - name: multiArcPropagatorSettings # [cpp]
        type: MultiArcPropagatorSettings# [cpp]
      - name: multi_arc_settings # [py]
        type: MultiArcPropagatorSettings # [py]
        description: MultiArcPropagatorSettings object to use for the propagation.

    returns:
        type: HybridArcPropagatorSettings
        description: Hybrid-arc propagator settings object.


  # Time termination
  - name: propagationTimeTerminationSettings # [cpp]
  - name: time_termination # [py]
    short_summary: "Factory function to create time termination settings for the propagation."
    extended_summary: |
      Factory function to create time termination settings for the propagation.
      The propagation is stopped when the final time provided is reached. Note that the termination time is set as the
      absolute time (in seconds since J2000), not the time since the start of the propagation.
      Depending on the sign of the time step of the numerical integrator, the termination time will be treated as an
      upper bound (for positive time step) or lower bound (for negative time step).
      The simulator will normally finish the final time-step, which may cause the termination time to be slightly exceeded.
      This behaviour can be suppressed by providing the optional input argument
      ``terminate_exactly_on_final_condition=True``, in which case the final propagation step will be *exactly* on the
      specified time.

    notes: |
      To reach *exactly* the final time, state derivative function evaluations beyond the final
      time may be required by the propagator. Reaching the final condition exactly is an iterative process and
      very minor deviations from the specified final condition can occur.

    parameters:
      - name: terminationTime # [cpp]
        type: double # [cpp]
      - name: termination_time # [py]
        type: float # [py]
        description: Final time of the propagation.

      - name: checkTerminationToExactCondition # [cpp]
        type: bool, default=false # [cpp]
      - name: terminate_exactly_on_final_condition # [py]
        type: bool, default=False # [py]
        description: Denotes whether the propagation is to terminate exactly on the final condition, or whether it is to terminate on the first step where it is violated.

    returns:
        type: PropagationTimeTerminationSettings
        description: Time termination settings object.

    examples: |
      In this example, we set the termination time of the propagation equal to one day (86400 $s$).

      .. code-block:: python

        # Set termination time (in seconds since J2000)
        termination_time = simulation_start_epoch + 86400.0
        # Create time termination settings
        termination_settings = propagation_setup.propagator.time_termination( termination_time )



  # CPU time termination
  - name: propagationCPUTimeTerminationSettings # [cpp]
  - name: cpu_time_termination # [py]
    short_summary: "Factory function to create CPU time termination settings for the propagation."
    extended_summary: |
      Factory function to create CPU time termination settings for the propagation.
      The propagation is stopped when the final CPU time provided is reached.

    parameters:
      - name: cpuTerminationTime # [cpp]
        type: double # [cpp]
      - name: cpu_termination_time # [py]
        type: float # [py]
        description: Maximum CPU time for the propagation.

    returns:
        type: PropagationCPUTimeTerminationSettings
        description: CPU time termination settings object.

    examples: |
      In this case, we set a CPU time termination setting so that the propagation stops once your computer has run it
      for 120 seconds.

      .. code-block:: python

        # Set CPU time to 120 seconds
        cpu_termination_time = 120.0
        # Create termination settings
        termination_settings = propagation_setup.propagator.cpu_time_termination( cpu_termination_time )


  # Dependent variable termination
  - name: propagationDependentVariableTerminationSettings # [cpp]
  - name: dependent_variable_termination # [py]
    short_summary: "Factory function to create termination settings for the propagation based on a dependent variable."
    extended_summary: |
      Factory function to create termination settings for the propagation based on the value of a dependent variable.
      The propagation is stopped when a provided upper or lower limit value is reached.
      The simulator will normally finish the final time-step, which may cause the dependent variable to be slightly exceeded.
      This behaviour can be suppressed by providing the optional input argument
      ``terminate_exactly_on_final_condition=True``, in which case the final propagation step will be *exactly* on the
      specified dependent variable value.

    notes: |
      To reach *exactly* the final dependent variable value, state derivative function evaluations beyond the final
      time may be required by the propagator. Reaching the final condition exactly is an iterative process and
      very minor deviations from the specified final condition can occur.

    parameters:
      - name: dependentVariableSettings # [cpp]
        type: SingleDependentVariableSaveSettings # [cpp]
      - name: dependent_variable_settings # [py]
        type: SingleDependentVariableSaveSettings # [py]
        description: Dependent variable object to be used as termination setting.

      - name: limitValue # [cpp]
        type: double # [cpp]
      - name: limit_value # [py]
        type: float # [py]
        description: Limit value of the dependent variable; if reached, the propagation is stopped.

      - name: useAsLowerLimit # [cpp]
        type: bool, default=false # [cpp]
      - name: use_as_lower_limit # [py]
        type: bool, default=False # [py]
        description: Denotes whether the limit value should be used as lower or upper limit.

      - name: checkTerminationToExactCondition # [cpp]
        type: bool, default=false # [cpp]
      - name: terminate_exactly_on_final_condition # [py]
        type: bool, default=False # [py]
        description: Denotes whether the propagation is to terminate exactly on the final condition, or whether it is to terminate on the first step where it is violated.

      - name: terminationRootFinderSettings # [cpp]
        type: bool, default=nullptr # [cpp]
      - name: termination_root_finder_settings # [py]
        type: bool, default=None # [py]
        description: Settings object to create root finder used to converge on exact final condition.

    returns:
        type: PropagationDependentVariableTerminationSettings
        description: Dependent variable termination settings object.

    examples: |
      Below, an example is shown for termination on a given vehicle altitude. The exact termination condition is defined
      in the ``termination_settings``. The propagation is terminated once the *lower* limit of 25 km in altitude is
      reached (as the ``use_as_lower_limit`` is set to ``True``). To use the above settings to terminate when an
      *upper* limit of 25 km is reached, set this boolean to ``False``. In this example, we also want to stop exactly
      at 25 km, so we set ``terminate_exactly_on_final_condition`` to ``True``, and we specify ``termination_root_finder_settings``.

      .. code-block:: python

        # Set dependent variable to be checked as termination setting
        termination_variable = propagation_setup.dependent_variable.altitude( "Spacecraft", "Earth" )
        # Create termination settings
        termination_settings = propagation_setup.propagator.dependent_variable_termination(
          dependent_variable_settings = termination_variable,
          limit_value = 25.0E3,
          use_as_lower_limit = True,
          terminate_exactly_on_final_condition=True,
          termination_root_finder_settings=root_finders.secant(
              maximum_iteration=5,
              maximum_iteration_handling=root_finders.MaximumIterationHandling.accept_result)
          )
        )


  # Custom termination
  - name: propagationCustomTerminationSettings # [cpp]
  - name: custom_termination # [py]
    short_summary: "Factory function to create custom termination settings for the propagation."
    extended_summary: |
      Factory function to create custom termination settings for the propagation.
      The propagation is stopped when the condition provided is verified.
      This custom function should take the current time as input and output a Boolean. It can use internal variables
      and calculations, for example retrieved from the environment.

    parameters:
      - name: checkStopCondition # [cpp]
        type: std::function<bool(double)> # [cpp]
      - name: custom_condition # [py]
        type: callable[[float], bool] # [py]
        description: Function of time (independent variable) which is called during the propagation and returns a boolean value denoting whether the termination condition is verified.

    returns:
        type: PropagationCustomTerminationSettings
        description: Custom termination settings object.

    examples: |

      .. code-block:: python

        # Create custom function returning a bool
        def custom_termination_function(time: float):
            # Do something
            set_condition = ...
            # Return bool
            return set_condition

        # Create termination settings
        termination_settings = propagation_setup.propagator.custom_termination(
          custom_termination_function)


  # Hybrid termination
  - name: PropagationHybridTerminationSettings # [cpp]
  - name: hybrid_termination # [py]
    short_summary: "Factory function to create hybrid termination settings for the propagation."
    extended_summary: |
      Factory function to create hybrid termination settings for the propagation. This function can be used
      to define that all conditions or a single condition of the conditions provided must be met to
      stop the propagation. Each termination condition should be created according to each individual factory function
      and then added to a list of termination conditions.

    parameters:
      - name: terminationSettings # [cpp]
        type: std::vector<PropagationTerminationSettings> # [cpp]
      - name: termination_settings # [py]
        type: list[PropagationTerminationSettings] # [py]
        description: List of single PropagationTerminationSettings objects to be checked during the propagation.

      - name: fulfillSingleCondition # [cpp]
        type: bool, default=false # [cpp]
      - name: fulfill_single_condition # [py]
        type: bool, default=False # [py]
        description: Whether only a single condition of those provided must be met to stop the propagation (true) or all of them simultaneously (false).

    returns:
        type: PropagationHybridTerminationSettings
        description: Hybrid termination settings object.

    examples: |
      In the following example, the propagation will terminate once *one of the three* termination settings (simulated time, cpu time, altitude)
      has reached the imposed limit value. The ``fulfill_single_condition`` variable determines whether the propagation
      terminates once a *single* condition is met (if True, as above) or once *all* conditions must be met (False).

      .. code-block:: python

        # Set simulation termination time
        termination_time = simulation_start_epoch + 86400.0
        # Create simulation time termination setting
        time_termination_settings = propagation_setup.propagator.time_termination( termination_time )

        # Set dependent variable termination setting
        termination_variable = propagation_setup.dependent_variable.altitude( "Spacecraft", "Earth" )
        # Create altitude-based termination setting
        altitude_termination_settings = propagation_setup.propagator.dependent_variable_termination(
          dependent_variable_settings = termination_variable,
          limit_value = 25.0E3,
          use_as_lower_limit = True)

        # Set cpu termination time
        cpu_termination_time = 120.0
        # Create cpu time termination setting
        cpu_termination_settings = propagation_setup.propagator.cpu_time_termination( cpu_termination_time )

        # Store termination setting objects in a list
        termination_settings_list = [time_termination_settings, altitude_termination_settings, cpu_termination_settings]

        # Create hybrid termination settings
        termination_settings = propagation_setup.propagator.hybrid_termination( termination_settings_list, fulfill_single_condition = True )


  - name: add_dependent_variable_settings # [py]
    short_summary: "Function to add dependent variables to existing propagator settings."

    extended_summary: |
      Function to add dependent variables to existing :class:`~tudatpy.numerical_simulation.propagation_setup.propagator.SingleArcPropagatorSettings`
      object. This function is added as an alternative to teh regular manner in which to defined dependent variables (use of input to factory
      functions for single-arc propagator settings :func:`~tudatpy.numerical_simulation.propagation_setup.propagator.translational`,
      :func:`~tudatpy.numerical_simulation.propagation_setup.propagator.rotational`, :func:`~tudatpy.numerical_simulation.propagation_setup.propagator.mass`,
      :func:`~tudatpy.numerical_simulation.propagation_setup.propagator.multitype`). Typically, this function is used to modify
      existing propagator settings in a loop when running multiple simulations

    parameters:
      - name: dependent_variable_settings # [py]
        type: List[ SingleDependentVariableSaveSettings ] # [py]
        description: List of dependent variable settings that are to be added to propagator settings. Note that this function
          adds settings, and does not replace any existing settings (nor does it check for duplicate settings).

      - name: propagator_settings # [py]
        type: SingleArcPropagatorSettings # [py]
        description: Propagator settings to which the additional dependent variables settings are to be added.

    returns:
      type: None # [py]
