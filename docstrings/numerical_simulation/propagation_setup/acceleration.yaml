extended_summary: |
  This module provides the functionality for creating acceleration
  settings.

# the structure of this file follows the order of expose_acceleration_setup.cpp (tudatpy) and
# includes tudat content for:
# - accelerationModelTypes.h
# - accelerationSettings.h

enums:

  - name: AvailableAcceleration
    short_summary: "Enumeration of available acceleration types."
    extended_summary: |
      Enumeration of acceleration types supported by tudat.
    members:
      - name: undefined_acceleration # [cpp]
      - name: point_mass_gravity # [cpp]
      - name: central_gravity # [cpp]
      - name: aerodynamic # [cpp]
      - name: cannon_ball_radiation_pressure # [cpp]
      - name: spherical_harmonic_gravity # [cpp]
      - name: mutual_spherical_harmonic_gravity # [cpp]
      - name: third_body_point_mass_gravity # [cpp]
      - name: third_body_central_gravity # [cpp]
      - name: third_body_spherical_harmonic_gravity # [cpp]
      - name: third_body_mutual_spherical_harmonic_gravity # [cpp]
      - name: thrust_acceleration # [cpp]
      - name: relativistic_correction_acceleration # [cpp]
      - name: empirical_acceleration # [cpp]
      - name: direct_tidal_dissipation_in_central_body_acceleration # [cpp]
      - name: direct_tidal_dissipation_in_orbiting_body_acceleration # [cpp]
      - name: panelled_radiation_pressure_acceleration # [cpp]
      - name: momentum_wheel_desaturation_acceleration # [cpp]
      - name: solar_sail_acceleration # [cpp]
      - name: custom_acceleration # [cpp]

      - name: undefined_acceleration_type # [py]
      - name: point_mass_gravity_type # [py]
      - name: aerodynamic_type # [py]
      - name: cannon_ball_radiation_pressure_type # [py]
      - name: spherical_harmonic_gravity_type # [py]
      - name: mutual_spherical_harmonic_gravity_type # [py]
      - name: thrust_acceleration_type # [py]
      - name: relativistic_correction_acceleration_type # [py]
      - name: empirical_acceleration_type # [py]
      - name: direct_tidal_dissipation_in_central_body_acceleration_type # [py]
      - name: direct_tidal_dissipation_in_orbiting_body_acceleration_type # [py]
      - name: panelled_radiation_pressure_acceleration_type # [py]
      - name: quasi_impulsive_shots_acceleration_type # [py]
      - name: solar_sail_acceleration_type # [py]
      - name: custom_acceleration_type # [py]



classes:


  # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
  ################## Acceleration settings ( accelerationSettings.h ) #################################################
  # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

  # base
  - name: AccelerationSettings
    short_summary: "Functional base class to define settings for accelerations."
    extended_summary: |
      Class for providing settings for acceleration model. This class is a functional (base) class for
      settings of acceleration models that  require no information in addition to their type.
      Classes defining settings for acceleration models requiring additional information must be derived from this class.
      Bodies exerting and undergoing acceleration are set externally from this class.
      This class can be used for the easy setup of acceleration models
      (see createAccelerationModels.h), but users may also chose to do so manually.
      (Derived) Class members are all public, for ease of access and modification.

    methods:
      - name: ctor # [cpp]
        short_summary: "Constructor." # [cpp]
        extended_summary: "Instances of this class are typically not generated by the user because this is a base class." # [cpp]


  # derived (1)
  - name: SphericalHarmonicAccelerationSettings
    short_summary: "`AccelerationSettings`-derived class to define settings for the spherical harmonic acceleration."
    extended_summary: |
      Class for providing settings for spherical harmonics acceleration model,
      including the maximum degree and order up to which the field is to be expanded. Note that
      the minimum degree and order are currently always set to zero.

    methods:
      - name: ctor # [cpp]
        short_summary: "Constructor." # [cpp]
        extended_summary: "Instances of this class are typically not generated by the user. Settings objects for dependent variables should be instantiated through factory functions of a derived class." # [cpp]


  # derived (2)
  - name: MutualSphericalHarmonicAccelerationSettings
    short_summary: "`AccelerationSettings`-derived class to define settings for the mutual spherical harmonic acceleration."
    extended_summary: |
      Class for providing settings for the mutual spherical harmonics acceleration model,
      including the maximum degree and order up to which the fields of the bodies are to be expanded. Note that
      the minimum degree and order are currently always set to zero.

    methods:
      - name: ctor # [cpp]
        short_summary: "Constructor." # [cpp]
        extended_summary: "Instances of this class are typically not generated by the user. Settings objects for dependent variables should be instantiated through factory functions of a derived class." # [cpp]


  # derived (3)
  - name: RelativisticAccelerationCorrectionSettings
    short_summary: "`AccelerationSettings`-derived class to define settings for the relativistic acceleration correction."
    extended_summary: |
      Class to provide settings for typical relativistic corrections to the dynamics of an orbiter: the
      Schwarzschild, Lense-Thirring and de Sitter terms (see 'General relativity and Space Geodesy' by L. Combrinck,
      2012).

    methods:
      - name: ctor # [cpp]
        short_summary: "Constructor." # [cpp]
        extended_summary: "Instances of this class are typically not generated by the user. Settings objects for dependent variables should be instantiated through factory functions of a derived class." # [cpp]


  # derived (4)
  - name: EmpiricalAccelerationSettings
    short_summary: "`AccelerationSettings`-derived class to define settings for the empirical acceleration."
    extended_summary: |
      Class to provide settings for empirical accelerations. These are expressed in the
      RSW frame, for which the magnitude is determined empirically (typically during an orbit determination process).
      The acceleration components are defined according to Montenbruck and Gill (2000), with a total of 9 components:
      a constant, sine and cosine term (with true anomaly as argument) for each of the three independent directions of
      the RSW frame.

    methods:
      - name: ctor # [cpp]
        short_summary: "Constructor." # [cpp]
        extended_summary: "Instances of this class are typically not generated by the user. Settings objects for dependent variables should be instantiated through factory functions of a derived class." # [cpp]


  # derived (5)
  - name: CustomAccelerationSettings
    short_summary: "`AccelerationSettings`-derived class to define settings for custom acceleration."
    extended_summary: |
      Class to provide settings for custom accelerations. This is done by means of a function and, if necessary,
      an associated scaling function.

    methods:
      - name: ctor # [cpp]
        short_summary: "Constructor." # [cpp]
        extended_summary: "Instances of this class are typically not generated by the user. Settings objects for dependent variables should be instantiated through factory functions of a derived class." # [cpp]


  # derived (6)
  - name: DirectTidalDissipationAccelerationSettings
    short_summary: "`AccelerationSettings`-derived class to define settings for direct tidal dissipation acceleration."
    extended_summary: |
      Class to provide settings for direct tidal dissipation accelerations. Creates settings for tidal accelerations.
      The direct of tidal effects in a satellite system is applied directly as an acceleration
      (as opposed to a modification of spherical harmonic coefficients).

    methods:
      - name: ctor # [cpp]
        short_summary: "Constructor." # [cpp]
        extended_summary: "Instances of this class are typically not generated by the user. Settings objects for dependent variables should be instantiated through factory functions of a derived class." # [cpp]


  # derived (7)
  - name: ThrustAccelerationSettings
    short_summary: "`AccelerationSettings`-derived class to define settings for direct tidal dissipation acceleration."
    extended_summary: |
      Class to provide settings for thrust acceleration. Settings for the direction and magnitude of the thrust
      are included.

    attributes:
      - name: thrustDirectionSettings_ # [cpp]
        type: ThrustDirectionSettings # [cpp]
      - name: direction_settings # [py]
        type: ThrustDirectionSettings # [py]
        description: Thrust direction settings object.

      - name: thrustMagnitudeSettings_ # [cpp]
        type: ThrustMagnitudeSettings # [cpp]
      - name: magnitude_settings # [py]
        type: ThrustMagnitudeSettings # [py]
        description: Thrust magnitude settings object.

    methods:
      - name: ctor # [cpp]
        short_summary: "Constructor." # [cpp]
        extended_summary: "Instances of this class are typically not generated by the user. Settings objects for dependent variables should be instantiated through factory functions of a derived class." # [cpp]


  # derived (8)
  - name: MomentumWheelDesaturationAccelerationSettings
    short_summary: "`AccelerationSettings`-derived class to define settings for momentum wheel desaturation acceleration."
    extended_summary: |
      Class to provide settings for momentum wheel desaturation acceleration. Settings for the direction and magnitude
      of the thrust are included.

    methods:
      - name: ctor # [cpp]
        short_summary: "Constructor." # [cpp]
        extended_summary: "Instances of this class are typically not generated by the user. Settings objects for dependent variables should be instantiated through factory functions of a derived class." # [cpp]


  
functions:

  # factory functions

  # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
  ################## Acceleration settings ( accelerationSettings.h ) #################################################
  # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

  # Point mass gravity
  - name: pointMassGravityAcceleration # [cpp]
  - name: point_mass_gravity # [py]
    short_summary: "Creates settings for the point-mass gravity acceleration."
    extended_summary: |
      Creates settings for the point-mass gravity acceleration. The body exerting the acceleration needs to have a
      gravity field model defined.

    returns:
        type: AccelerationSettings
        description: Acceleration settings object.

    examples: |
      In this example, we define the point mass gravity acceleration exerted by the Earth on the vehicle:

      .. code-block:: python # [py]
         # [py]
         # Create acceleration dict # [py]
         accelerations_acting_on_vehicle = dict() # [py]
         # Add aerodynamic acceleration exerted by Earth # [py]
         accelerations_acting_on_vehicle["Earth"] = [propagation_setup.acceleration.point_mass_gravity()] # [py]

#      .. code-block:: cpp # [cpp]
#
#         // Declare the acceleration settings map # [cpp]
#         SelectedAccelerationMap accelerationSettings; # [cpp]
#         // Add the acceleration to the map # [cpp]
#         accelerationSettings["Vehicle"]["Earth"].push_back(std::make_shared< AccelerationSettings >( central_gravity ) ); # [cpp]


  # Aerodynamic
  - name: aerodynamicAcceleration # [cpp]
  - name: aerodynamic # [py]
    short_summary: "Creates settings for the aerodynamic acceleration."
    extended_summary: |
      Creates settings for the aerodynamic acceleration. The body exerting the acceleration needs to have an
      atmosphere defined.

    returns:
        type: AccelerationSettings
        description: Acceleration settings object.

    examples: |
      In this example, we define the aerodynamic acceleration exerted by the Earth on the vehicle:

      .. code-block:: python # [py]
         # [py]
         # Create acceleration dict # [py]
         accelerations_acting_on_vehicle = dict() # [py]
         # Add aerodynamic acceleration exerted by Earth # [py]
         accelerations_acting_on_vehicle["Earth"] = [propagation_setup.acceleration.aerodynamic()] # [py]

#      .. code-block:: cpp # [cpp]
#         // Declare the acceleration settings map # [cpp]
#         SelectedAccelerationMap accelerationSettings; # [cpp]
#         // Add the acceleration to the map # [cpp]
#         accelerationSettings["Vehicle"]["Earth"].push_back(std::make_shared< AccelerationSettings >( aerodynamic ) ); # [cpp]


  # Cannonball radiation pressure
  - name: cannonBallRadiationPressureAcceleration # [cpp]
  - name: cannonball_radiation_pressure # [py]
    short_summary: "Creates settings for the cannonball radiation pressure acceleration."
    extended_summary: |
      Creates settings for the radiation pressure acceleration, for which a cannonball model is used. In this model,
      the effective acceleration is colinear with the vector connecting the source of radiation and the target.
      The body undergoing the acceleration needs to have a radiation pressure model defined, while the body emitting
      radiation needs to have radiative properties defined (the Sun has default ones).

    returns:
        type: AccelerationSettings
        description: Acceleration settings object.

    examples: |
      In this example, we define the aerodynamic acceleration exerted by the Sun on the vehicle:

      .. code-block:: python # [py]
         # [py]
         # Create acceleration dict # [py]
         accelerations_acting_on_vehicle = dict() # [py]
         # Add aerodynamic acceleration exerted by Earth # [py]
         accelerations_acting_on_vehicle["Sun"] = [propagation_setup.acceleration.cannonball_radiation_pressure()] # [py]

#      .. code-block:: cpp # [cpp]
#         // Declare the acceleration settings map # [cpp]
#         SelectedAccelerationMap accelerationSettings; # [cpp]
#         // Add the acceleration to the map # [cpp]
#         accelerationSettings["Vehicle"]["Sun"].push_back(std::make_shared< AccelerationSettings >( cannon_ball_radiation_pressure ) ); # [cpp]


  # Spherical harmonic gravity
  - name: sphericalHarmonicAcceleration # [cpp]
  - name: spherical_harmonic_gravity # [py]
    short_summary: "Creates settings for the spherical harmonic gravity acceleration."
    extended_summary: |
      Creates settings for the spherical harmonic gravity acceleration, accounting for a finite (given) number
      of degree and order. The body exerting the acceleration needs to have a spherical harmonic gravity field model
      defined.

    parameters:
      - name: maximumDegree # [cpp]
        type: int # [cpp]
      - name: maximum_degree # [py]
        type: int # [py]
        description: Maximum degree of the spherical harmonic expansion.

      - name: maximumOrder # [cpp]
        type: int # [cpp]
      - name: maximum_order # [py]
        type: int # [py]
        description: Maximum order of the spherical harmonic expansion.

    returns:
        type: SphericalHarmonicAccelerationSettings
        description: Spherical harmonic acceleration settings object.

    examples: |
      In this example, we define the spherical harmonic gravity acceleration (where the gravity field is expanded
      up to degree 12 and order 6) exerted by the Earth on the vehicle:

      .. code-block:: python # [py]
         # [py]
         # Define the maximum degree and order # [py]
         maximum_degree = 12 # [py]
         maximum_order = 6 # [py]
         # Create acceleration dict # [py]
         accelerations_acting_on_vehicle = dict() # [py]
         # Add aerodynamic acceleration exerted by Earth # [py]
         accelerations_acting_on_vehicle["Earth"] = [propagation_setup.acceleration.spherical_harmonic_gravity( # [py]
              maximum_degree,  # [py]
              maximum_order)] # [py]

#      .. code-block:: cpp # [cpp]
#          // Declare the acceleration settings map # [cpp]
#          SelectedAccelerationMap accelerationSettings; # [cpp]
#          // Define the maximum degree and order # [cpp]
#          int maximumDegree = 12; # [cpp]
#          int maximumOrder = 6; # [cpp]
#          // Add the acceleration to the map # [cpp]
#          accelerationSettings[ "Vehicle" ][ "Earth" ].push_back(std::make_shared< SphericalHarmonicAccelerationSettings >( maximumDegree, maximumOrder ) ); # [cpp]


  # Mutual spherical harmonic gravity
  - name: mutualSphericalHarmonicAcceleration # [cpp]
  - name: mutual_spherical_harmonic_gravity # [py]
    short_summary: "Creates settings for the mutual spherical harmonic gravity acceleration."
    extended_summary: |
      Creates settings for the mutual spherical harmonic gravity acceleration, accounting for a finite (given) number
      of degree and order for both bodies. Both the body exerting the acceleration and the body undergoing it need to
      have spherical harmonic gravity field models defined. In addition, the body undergoing the acceleration needs to
      have a rotational model defined. For the case where a third-body mutual spherical harmonic acceleration,
      additional parameters have to be provided that denote the expansion degree/order of the central body.

    parameters:
      - name: maximumDegreeOfBodyExertingAcceleration # [cpp]
        type: int # [cpp]
      - name: maximum_degree_body_exerting # [py]
        type: int # [py]
        description: Maximum degree of the spherical harmonic expansion for the body exerting the acceleration.

      - name: maximumOrderOfBodyExertingAcceleration # [cpp]
        type: int # [cpp]
      - name: maximum_order_body_exerting # [py]
        type: int # [py]
        description: Maximum order of the spherical harmonic expansion for the body exerting the acceleration.

      - name: maximumDegreeOfBodyUndergoingAcceleration # [cpp]
        type: int # [cpp]
      - name: maximum_degree_body_undergoing # [py]
        type: int # [py]
        description: Maximum degree of the spherical harmonic expansion for the body undergoing the acceleration.

      - name: maximumOrderOfBodyUndergoingAcceleration # [cpp]
        type: int # [cpp]
      - name: maximum_order_body_undergoing # [py]
        type: int # [py]
        description: Maximum order of the spherical harmonic expansion for the body undergoing the acceleration.

      - name: maximumDegreeOfCentralBody # [cpp]
        type: int, default=0 # [cpp]
      - name: maximum_degree_central_body # [py]
        type: int, default=0 # [py]
        description: Maximum degree of the spherical harmonic expansion for the central body, if needed.

      - name: maximumOrderOfCentralBody # [cpp]
        type: int, default=0 # [cpp]
      - name: maximum_order_central_body # [py]
        type: int, default=0 # [py]
        description: Maximum order of the spherical harmonic expansion for the central body, if needed.

    returns:
        type: MutualSphericalHarmonicAccelerationSettings
        description: Spherical harmonic acceleration settings object.

    examples: |
      In this example, we define the spherical harmonic gravity accelerations exerted on Io by Jupiter and vice-versa.

      .. code-block:: python # [py]
         # [py]
         # Define the maximum degree and order for both bodies # [py]
         maximum_degree_of_io = 12 # [py]
         maximum_order_of_io = 12 # [py]
         maximum_degree_of_jupiter = 4 # [py]
         maximum_order_of_jupiter = 4 # [py]
         # Create acceleration dict # [py]
         acceleration_settings_on_io = dict() # [py]
         # Add aerodynamic acceleration exerted by Earth # [py]
         acceleration_settings_on_io["Jupiter"] = [propagation_setup.acceleration.mutual_spherical_harmonic_gravity( # [py]
              maximum_degree_of_jupiter, # [py]
              maximum_order_of_jupiter, # [py]
              maximum_degree_of_io, # [py]
              maximum_order_of_io)] # [py]

      For the case where the mutual spherical harmonic acceleration is a third-body acceleration,
      additional parameters have to be provided to denote the expansion of the spherical harmonics of the central body.
      In the following example, we consider the spherical harmonic gravity acceleration mutually exerted between
      Ganymede and Io when propagating w.r.t. Jupiter:

      .. code-block:: python # [py]
         # [py]
         # Define the maximum degree and order for both bodies # [py]
         maximum_degree_of_jupiter = 4 # [py]
         maximum_order_of_jupiter = 4 # [py]
         maximum_degree_of_ganymede = 4 # [py]
         maximum_order_of_ganymede = 4 # [py]
         maximum_degree_of_io = 12 # [py]
         maximum_order_of_io = 12 # [py]
         # Create acceleration dict # [py]
         acceleration_settings_on_io = dict() # [py]
         # Add the acceleration to the dict # [py]
         acceleration_settings_on_io["Jupiter"] = [propagation_setup.acceleration.mutual_spherical_harmonic_gravity( # [py]
              maximum_degree_of_jupiter, # [py]
              maximum_order_of_jupiter, # [py]
              maximum_degree_of_ganymede, # [py]
              maximum_order_of_ganymede, # [py]
              maximum_degree_of_io, # [py]
              maximum_order_of_io)] # [py]

#      .. code-block:: cpp # [cpp]
#          // Declare the acceleration settings map # [cpp]
#          SelectedAccelerationMap accelerationSettings; # [cpp]
#          // Define the maximum degree and order for both bodies # [cpp]
#          int maximumDegreeOfIo = 12; # [cpp]
#          int maximumOrderOfIo = 12; # [cpp]
#          int maximumDegreeOfJupiter = 4; # [cpp]
#          int maximumOrderOfJupiter = 4; # [cpp]
#          // Add the acceleration to the map # [cpp]
#          accelerationSettings[ "Io" ][ "Jupiter" ].push_back( std::make_shared< MutualSphericalHarmonicAccelerationSettings >(
#          maximumDegreeOfJupiter, # [cpp]
#          maximumOrderOfJupiter, # [cpp]
#          maximumDegreeOfIo, # [cpp]
#          maximumOrderOfIo ) ); # [cpp]

#          .. code-block:: cpp # [cpp]
#          // Declare the acceleration settings map # [cpp]
#          SelectedAccelerationMap accelerationSettings; # [cpp]
#          // Define the maximum degree and order for both bodies # [cpp]
#          int maximumDegreeOfIo = 12; # [cpp]
#          int maximumOrderOfIo = 12; # [cpp]
#          int maximumDegreeOfGanymede = 4; # [cpp]
#          int maximumOrderOfGanymede = 4; # [cpp]
#          int maximumDegreeOfJupiter = 4; # [cpp]
#          int maximumOrderOfJupiter = 4; # [cpp]
#          // Add the acceleration to the map # [cpp]
#          accelerationSettings[ "Io" ][ "Jupiter" ].push_back( std::make_shared< MutualSphericalHarmonicAccelerationSettings >(
#          maximumDegreeOfJupiter,  # [cpp]
#          maximumOrderOfJupiter,  # [cpp]
#          maximumDegreeOfGanymede,  # [cpp]
#          maximumOrderOfGanymede,  # [cpp]
#          maximumDegreeOfIo,  # [cpp]
#          maximumOrderOfIo ) ); # [cpp]


  # Relativistic correction
  - name: relativisticAccelerationCorrection # [cpp]
  - name: relativistic_correction # [py]
    short_summary: "Creates settings for the relativistic acceleration correction."
    extended_summary: |
      Creates settings for typical relativistic acceleration corrections: the Schwarzschild, Lense-Thirring and de
      Sitter terms, where each of the three terms can be toggled on or of (see 'General relativity and Space Geodesy' by L. Combrinck, 2012). It implements the model of
      2010 Conventions (chapter 10, section 3). Here, the ‘primary body’ for a planetary orbiter should always be set
      as the Sun (only relevant for de Sitter correction). The angular momentum vector of the orbited body is only
      relevant for Lense-Thirring correction.

    parameters:
      - name: calculateSchwarzschildCorrection # [cpp]
        type: bool # [cpp]
      - name: use_schwarzschild # [py]
        type: bool # [py]
        description: Maximum degree of the spherical harmonic expansion for the body exerting the acceleration.

      - name: calculateLenseThirringCorrection # [cpp]
        type: bool # [cpp]
      - name: use_lense_thirring # [py]
        type: bool # [py]
        description: Maximum order of the spherical harmonic expansion for the body exerting the acceleration.

      - name: calculateDeSitterCorrection # [cpp]
        type: bool # [cpp]
      - name: use_de_sitter # [py]
        type: bool # [py]
        description: Maximum degree of the spherical harmonic expansion for the body undergoing the acceleration.

      - name: primaryBody # [cpp]
        type: std::string, default="" # [cpp]
      - name: de_sitter_central_body # [py]
        type: str, default="" # [py]
        description: Maximum order of the spherical harmonic expansion for the body undergoing the acceleration.

      - name: centralBodyAngularMomentum # [cpp]
        type: Eigen::Vector3d, default=Eigen::Vector3d::Zero() # [cpp]
      - name: lense_thirring_angular_momentum # [py]
        type: numpy.ndarray, default=numpy.array([0, 0, 0]) # [py]
        description: Maximum degree of the spherical harmonic expansion for the central body, if needed.

    returns:
        type: RelativisticAccelerationCorrectionSettings
        description: Relativistic acceleration correction settings object.

    examples: |
      In this example, we define the relativistic correction acceleration for a Mars orbiter:

      .. code-block:: python # [py]
         # [py]
         # Select terms to be used # [py]
         use_schwarzschild = True # [py]
         use_lense_thirring = True # [py]
         use_de_sitter = True # [py]
         # Define central body for De-Sitter term # [py]
         de_sitter_central_body = "Sun" # [py]
         # Define angular momentum for the Lense-Thirring term # [py]
         lense_thirring_angular_momentum = ... # numpy.ndarray 3D vector # [py]
         # Create acceleration dict # [py]
         acceleration_settings_on_vehicle = dict() # [py]
         # Add the acceleration to the dict # [py]
         acceleration_settings_on_vehicle["Mars"] = [propagation_setup.acceleration.relativistic_correction( # [py]
            use_schwarzschild, # [py]
            use_lense_thirring,  # [py]
            use_de_sitter,  # [py]
            de_sitter_central_body,  # [py]
            lense_thirring_angular_momentum)] # [py]

#      .. code-block:: cpp # [cpp]
#
#          // Declare the acceleration settings map # [cpp]
#          SelectedAccelerationMap accelerationSettings;
#          // Select terms to be used # [cpp]
#          bool calculateSchwarzschildCorrection = true; # [cpp]
#          bool calculateLenseThirringCorrection = true; # [cpp]
#          bool calculateDeSitterCorrection = true; # [cpp]
#          // Define central body for De-Sitter term # [cpp]
#          std::string primaryBody = "Sun"; # [cpp]
#          // Define angular momentum for the Lense-Thirring term # [cpp]
#          const Eigen::Vector3d centralBodyAngularMomentum = ...  // Eigen 3D vector # [cpp]
#          // Add the acceleration to the dict # [cpp]
#          accelerationSettings[ "Vehicle" ][ "Mars" ] = std::make_shared< RelativisticAccelerationCorrectionSettings >( # [cpp]
#              calculateSchwarzschildCorrection,  # [cpp]
#              calculateLenseThirringCorrection,   # [cpp]
#              calculateDeSitterCorrection,  # [cpp]
#              primaryBody,  # [cpp]
#              centralBodyAngularMomentum ) # [cpp]


  # Empirical
  - name: empiricalAcceleration # [cpp]
  - name: empirical # [py]
    short_summary: "Creates settings for empirical acceleration."
    extended_summary: |
      Creates settings for empirical accelerations. These are expressed in the
      RSW frame, for which the magnitude is determined empirically (typically during an orbit determination process).
      The acceleration components are defined according to Montenbruck and Gill (2000), with a total of 9 components:
      a constant, sine and cosine term (with true anomaly as argument) for each of the three independent directions of
      the RSW frame. The empirical acceleration is calculated as:

       .. math::

          \mathbf{a}=R^{I/RSW}\left(\mathbf{a}_{\text{const.}}+\mathbf{a}_{\sin}\sin\theta+\mathbf{a}_{\cos}\cos\theta \right)

      Here, :math:`R^{I/RSW}` is the rotation matrix from the RSW frame (of the body undergoing the acceleration w.r.t. the
      body exerting the acceleration), :math:`theta` is the true anomaly, and the three constituent acceleration vectors are
      the inputs provided in the above code block. The body 'exerting' the acceleration is considered to be the
      central body, w.r.t. which the true anomaly is calculated.


    parameters:
      - name: constantAcceleration # [cpp]
        type: Eigen::Vector3d, default=Eigen::Vector3d::Zero() # [cpp]
      - name: constant_acceleration # [py]
        type: numpy.ndarray, default=numpy.array([0, 0, 0]) # [py]
        description: Constant term, defined in the RSW frame.

      - name: sineAcceleration # [cpp]
        type: Eigen::Vector3d, default=Eigen::Vector3d::Zero() # [cpp]
      - name: sine_acceleration # [py]
        type: numpy.ndarray, default=numpy.array([0, 0, 0]) # [py]
        description: Sine term (function of the true anomaly), defined in the RSW frame..

      - name: cosineAcceleration # [cpp]
        type: Eigen::Vector3d, default=Eigen::Vector3d::Zero() # [cpp]
      - name: cosine_acceleration # [py]
        type: numpy.ndarray, default=numpy.array([0, 0, 0]) # [py]
        description: Cosine term (function of the true anomaly), defined in the RSW frame..

    returns:
        type: EmpiricalAccelerationSettings
        description: Empirical acceleration settings object.

    examples: |
      In this example, we define the empirical acceleration acting on the vehicle. The body that 'exerts' the acceleration
      is here used to determine the body w.r.t. which the true anomaly has o be calculated when determining the sine/cosine
      contributions. This central body must be endowed with a gravity field (so that it possesses a gravitational parameter
      for the Cartesian to Keplerian conversion)

      .. code-block:: python # [py]
         # [py]
         # Define the nine terms (constant, sine and cosine) # [py]
         constant_acceleration = ... # 3D numpy.ndarray vector # [py]
         sine_acceleration = ... # 3D numpy.ndarray vector # [py]
         cosine_acceleration = ... # 3D numpy.ndarray vector # [py]
         # Create acceleration dict # [py]
         acceleration_settings_on_vehicle = dict() # [py]
         # Add the acceleration to the dict # [py]
         acceleration_settings_on_vehicle["Sun"] = [propagation_setup.acceleration.empirical( # [py]
             constant_acceleration,  # [py]
             sine_acceleration,  # [py]
             cosine_acceleration)] # [py]

#      .. code-block:: cpp # [cpp]
#
#         // Declare the acceleration settings map # [cpp]
#          SelectedAccelerationMap accelerationSettings; # [cpp]
#          // Define the nine terms (constant, sine and cosine) # [cpp]
#          Eigen::Vector3d constantAcceleration = ( Eigen::Vector3d( ) << 0.4, -0.1, 0.05 ).finished( ); # [cpp]
#          Eigen::Vector3d sineAcceleration = ( Eigen::Vector3d( ) << 0.0, 0.02, 0.0 ).finished( ); # [cpp]
#          Eigen::Vector3d cosineAcceleration = ( Eigen::Vector3d( ) << -0.01, 0.0, 0.0 ).finished( ); # [cpp]
#          // Add the acceleration to the map # [cpp]
#          accelerationSettings[ "Orbiter" ][ "Mars" ] = std::make_shared< EmpiricalAccelerationSettings >( # [cpp]
#             constantAcceleration, sineAcceleration, cosineAcceleration ); # [cpp]


  # Custom
  - name: customAccelerationSettings # [cpp]
  - name: custom # [py]
    short_summary: "Creates settings for custom acceleration."
    extended_summary: |
      Creates settings for a custom accelerations, this acceleration must be parameterized as a function of time,
      and expressed with an inertial orientation.

    parameters:
      - name: accelerationFunction # [cpp]
        type: std::function<Eigen::Vector3d(const double)> # [cpp]
      - name: acceleration_function # [py]
        type: callable[[float], list] # [py]
        description: Custom acceleration function with time as an independent variable, returning the acceleration
          in an inertial frame (*e.g.* with global frame orientation) as a function of time.

      #- name: scalingFunction # [cpp]
        #type: std::function<double(const double)>, default=nullptr # [cpp]
      #- name: scaling_function # [py]
        #type: callable[[float], float], default=None # [py]
        #description: Scaling function with time as an independent variable to be multiplied by the custom acceleration function.

    returns:
        type: CustomAccelerationSettings
        description: Custom acceleration settings object.

    examples: |
      In this example, we define a simple, standalone, custom acceleration (depending only on time),
      with the following (arbitrary, for the sake of example) mathematical definition:

       .. math::

          \mathbf{a}=\begin{pmatrix}C\\0\\0 \end{pmatrix}\sin\left(\frac{t-t_{0}}{T}\right)

      with :math:`C=10^{-8}`, :math:`t_{0}=0` and :math:`T=86400`.
      More complex custom acceleration functions can be created by, for instance, extracting the
      custom function from a user-defined class, which may in turn have other simulation objects
      (*e.g.* :class:`SystemOfBodies`) as members, allowing the custom acceleration to depend on
      the current simulation state/environment

      .. code-block:: python # [py]
         # [py]
         # Define custom function # [py]
         def custom_function( current_time ): # [py]
             period = 86400.0 # [py]
             reference_time = 0.0 # [py]
             phase = np.pi * ( current_time - reference_time ) / period # [py]
             return np.array([1.0E-8, 0.0, 0.0]) * np.sin(phase) # [py]
         # [py]
         acceleration_settings_on_vehicle["Vehicle"] = [propagation_setup.acceleration.custom( # [py]
             custom_function)] # [py]

  # Direct tidal dissipation
  - name: directTidalDissipationAcceleration # [cpp]
  - name: direct_tidal_dissipation_acceleration # [py]
    short_summary: "Creates settings for custom acceleration."
    extended_summary: |
      Creates settings for tidal accelerations. The direct of tidal effects in a satellite system is applied directly as
      an acceleration (as opposed to a modification of spherical harmonic coefficients).
      The model is based on Lainey et al. (2007, 2012). It can compute the acceleration due to tides, and in
      particular tidal dissipation, on a planetary satellite. The acceleration computed can account for either the
      effect of tide raised on the satellite by the planet or on the planet by the satellite. The satellite is assumed
      to be tidally locked to the planet.

    parameters:
      - name: k2LoveNumber # [cpp]
        type: double # [cpp]
      - name: k2_love_number # [py]
        type: float # [py]
        description: Value of the k2 Love number.

      - name: timeLag # [cpp]
        type: double # [cpp]
      - name: time_lag # [py]
        type: float # [py]
        description: Value of the tidal time lag.

      - name: includeDirectRadialComponent # [cpp]
        type: bool, default=true # [cpp]
      - name: include_direct_radial_component # [py]
        type: bool, default=True # [py]
        description: It denotes whether the term independent of the time lag is to be computed.

      - name: useTideRaisedOnPlanet # [cpp]
        type: bool, default=true # [cpp]
      - name: use_tide_raised_on_planet # [py]
        type: bool, default=True # [py]
        description: It denotes whether the tide raised on the planet is to be modelled (if true) or the tide raised on the satellite (if false).

    returns:
        type: DirectTidalDissipationAccelerationSettings
        description: Direct tidal dissipation acceleration settings object.

    examples: |
      In this example, we define the tidal dissipation exerted by Jupiter on Io directly, instead of computing it
      through the spherical harmonic gravity:

      .. code-block:: python # [py]
         # [py]
         # Define parameters # [py]
         love_number = 0.1 # [py]
         time_lag = 100.0 # [py]
         # Add entry to acceleration settings dict # [py]
         acceleration_settings_on_io["Jupiter"] = [propagation_setup.acceleration.direct_tidal_dissipation( # [py]
            love_number,  # [py]
            time_lag,  # [py]
            False,  # [py]
            False)] # [py]

  # Momentum wheel desaturation
  - name: momentumWheelDesaturationAcceleration # [cpp]
  - name: quasi_impulsive_shots_acceleration # [py]
    short_summary: "Creates settings for incorporating quasi-impulsive shots into the acceleration."
    extended_summary: |
      The acceleration model is purpose-built to represent short bursts of thrust, such as a momentum wheel desaturation.
      A typical use case is precise orbit determination, but the functionality can be used just as well in propagation
      (for instance to model an impulsive manuever in a continuous manner when going from preliminary modelling to
      'full' modelling). The thrust is modelled similarly to Fig. 3 of Alessi et al. (2012), with the main difference
      being that a third-order polynomial to go from zero acceleration to the maximum acceleration level is employed.
      By using a 3rd-order polynomial and imposing continuity in the value and first derivative of the acceleration,
      defining the 'rise time' (time it takes acceleration to go from 0 to its maximum level), the total time where
      there is non-zero thrust ('total maneuver time'), and the total Delta V exerted by a single maneuver,
      the acceleration profile is fully defined.

    parameters:
      - name: thrustMidTimes # [cpp]
        type: std::vector<double> # [cpp]
      - name: thrust_mid_times # [py]
        type: list[float] # [py]
        description: Set of middle point in times in the maneuver denoting the epoch of each maneuver.

      - name: deltaVValues # [cpp]
        type: std::vector<Eigen::Vector3d> # [cpp]
      - name: delta_v_values # [py]
        type: list[numpy.ndarray] # [py]
        description: Set of delta V, one for each maneuver.

      - name: totalManeuverTime # [cpp]
        type: double # [cpp]
      - name: total_maneuver_time # [py]
        type: float # [py]
        description: Total duration of every maneuver.

      - name: maneuverRiseTime # [cpp]
        type: double # [cpp]
      - name: maneuver_rise_time # [py]
        type: float # [py]
        description: Time taken by the acceleration to go from zero to its maximum level.

    returns:
        type: MomentumWheelDesaturationAccelerationSettings
        description: Momentum wheel desaturation acceleration settings object.

    examples: |
      In this example, we define an acceleration model to represent two quasi-impulsive shots, with a total duration of
      30 seconds, and a rise time of 5 seconds. The maneuvers are to be done at :math:`t=86400` and :math:`t=2*86400`.
      The first maneuver is exclusively in :math:`x-`direction, and the second one exclusively in :math:`y-`direction,
      with both maneuvers having a magnitude of 1 mm/s

      .. code-block:: python # [py]
         # [py]
         # Define the quasi-impulsive shot settings # [py]
         mid_times = [ 86400.0, 2.0 * 86400.0] # [py]
         delta_v_values = [ np.array([1.0E-3, 0.0, 0.0]), np.array([0.0, 1.0E-3, 0.0]) ] # [py]
         maneuver_duration = 30 # [py]
         maneuver_duration = 5 # [py]
         # [py]
         # Create acceleration dict # [py]
         acceleration_settings_on_spacecraft = dict() # [py]
         # [py]
         # Add quasi-impulsive acceleration exerted by Spacecraft itself (!) # [py]
         acceleration_settings_on_spacecraft["Spacecraft"] = [propagation_setup.acceleration.quasi_impulsive_shots_acceleration( # [py]
              mid_times, # [py]
              delta_v_values, # [py]
              maneuver_duration, # [py]
              maneuver_duration)] # [py]


  # Thrust acceleration (overload 1)
  - name: thrustAcceleration # [cpp]
  - name: thrust_from_direction_and_magnitude # [py]
    short_summary: "Creates settings for thrust acceleration from thrust guidance settings."
    extended_summary: |
      Creates settings for thrust acceleration from thrust guidance settings. The thrust direction and magnitude are
      supplied  separately in the form of dedicated settings objects (see the API for the respective classes in the
      :ref:`\`\`thrust\`\`` module).

    parameters:
      - name: ThrustDirectionSettings # [cpp]
        type: ThrustDirectionSettings # [cpp]
      - name: thrust_direction_settings # [py]
        type: ThrustDirectionSettings # [py]
        description: Thrust direction settings object.

      - name: thrustMagnitudeSettings # [cpp]
        type: ThrustMagnitudeSettings # [cpp]
      - name: thrust_magnitude_settings # [py]
        type: ThrustMagnitudeSettings # [py]
        description: Thrust magnitude settings object.

    returns:
        type: ThrustAccelerationSettings
        description: Thrust acceleration settings object.

    examples: |
      In this example, we define thrust along the velocity vector (w.r.t. Earth), with a constant magnitude of 10 N and :math:`I_{sp}` of 300 s

      .. code-block:: python # [py]
         # [py]
         # Define thrust direction and magnitude # [py]
         thrust_direction_settings = (  # [py]
             propagation_setup.thrust.thrust_direction_from_state_guidance(  # [py]
                 central_body="Earth",  # [py]
                 is_colinear_with_velocity=True, # [py]
                 direction_is_opposite_to_vector=False ) ) # [py]
          # [py]
         thrust_magnitude_settings = ( # [py]
             propagation_setup.thrust.constant_thrust_magnitude( # [py]
                 thrust_magnitude=10, specific_impulse=300 ) ) # [py]

         # [py]
         # Create acceleration dict # [py]
         acceleration_settings_on_spacecraft = dict() # [py]
         # [py]
         # Add thrust exerted by Spacecraft itself (!) # [py]
         acceleration_settings_on_spacecraft ["Spacecraft" ] =[
           propagation_setup.acceleration.thrust_from_direction_and_magnitude(
             thrust_direction_settings=thrust_direction_settings,
             thrust_magnitude_settings=thrust_magnitude_settings,
         )
         ]


  # Thrust acceleration (overload 3)
  - name: thrustAcceleration # [cpp]
  - name: thrust_from_custom_function # [py]
    short_summary: "Creates settings for thrust acceleration using a custom user-defined thrust function."
    extended_summary: |
      Creates settings for thrust acceleration from a user-defined function providing the thrust as a function of time.
      This function may be defined in any number of ways, such as an interpolator, or a custom function that directly accesses the
      environment. The custom thrust function returns the total thrust force vector in the specified frame (default inertial, *e.g.*
      axes along the global orientation of the environment).

    parameters:
      - name: thrustForceFunction # [cpp]
        type: DataInterpolationSettingsVector3d # [cpp]
      - name: thrust_force_function # [py]
        type: callable[[float], numpy.ndarray[numpy.float64[3, 1]]] # [py]
        description: Function returning the thrust force vector, in the specified frame, as a function of time

      - name: constantSpecificImpulse # [cpp]
        type: double # [cpp]
      - name: constant_specific_impulse # [py]
        type: float # [py]
        description: Constant specific impulse.

      - name: thrustFrame # [cpp]
        type: ThrustFrames, default=inertial_thrust_frame # [cpp]
      - name: thrust_frame # [py]
        type: ThrustFrames, default=inertial_thrust_frame # [py]
        description: Frame in which the thrust direction vector is represented.

      - name: centralBody # [cpp]
        type: std::string, default="" # [cpp]
      - name: central_body # [py]
        type: str, default="" # [py]
        description: Central body that is the origin of the thrust frame (if different from the vehicle, otherwise empty by default).

    returns:
        type: ThrustAccelerationSettings
        description: Thrust acceleration settings object.

    examples: |
      In this example, we define the full thrust force using a cubic-spline interpolator, and a constant specific impulse. In this example, the thrust in the interpolated dict is applied in the TNW frame

      .. code-block:: python # [py]
         # [py]
         # Define dict that is to hold thrust at data points that are to be interpolated
         thrust_per_epoch = dict( )
         # Define thrust per epoch (manually or externally) # [py]
         thrust_per_epoch[ ... ] = ... # [py]
         # Create thrust interpolator # [py]
         interpolator_settings = math.interpolators.cubic_spline_interpolation( ) # [py]
         thrust_interpolator = math.interpolators.create_one_dimensional_interpolator( thrust_per_epoch, interpolator_settings ) # [py]
         # [py]
         # Create acceleration dict # [py]
         acceleration_settings_on_spacecraft = dict() # [py]
         # [py]
         # Add thrust exerted by Spacecraft itself (!) # [py]
         acceleration_settings_on_spacecraft ["Spacecraft" ] =[
           propagation_setup.acceleration.thrust_from_custom_function(
             thrust_force_function = thrust_interpolator.interpolate,
             constant_specific_impulse = 300.0,
             thrust_frame = propagation_setup.thrust.tnw_thrust_frame_type
         )
         ]

  # Thrust acceleration (overload 2)
  - name: thrustAcceleration # [cpp]
  - name: thrust_and_isp_from_custom_function # [py]
    short_summary: "Creates settings for thrust acceleration using a custom user-defined thrust and specific impulse functions."
    extended_summary: |
      As :func:`~tudatpy.numerical_simulation.propagation_setup.acceleration.thrust_from_custom_function`, but with the specific impulse defined by a custom function (with time as input)

    parameters:
      - name: thrustForceFunction # [cpp]
        type: DataInterpolationSettingsVector3d # [cpp]
      - name: thrust_force_function # [py]
        type: callable[[float], numpy.ndarray[numpy.float64[3, 1]]] # [py]
        description: Function returning the thrust force vector, in the specified frame, as a function of time

      - name: specificImpulseFunction # [cpp]
        type: std::function<double(double)> # [cpp]
      - name: specific_impulse_function # [py]
        type: callable[[float], float] # [py]
        description: Specific impulse provided as a function of time.

      - name: thrustFrame # [cpp]
        type: ThrustFrames, default=inertial_thrust_frame # [cpp]
      - name: thrust_frame # [py]
        type: ThrustFrames, default=inertial_thrust_frame # [py]
        description: Frame in which the thrust direction vector is represented.

      - name: centralBody # [cpp]
        type: std::string, default="" # [cpp]
      - name: central_body # [py]
        type: str, default="" # [py]
        description: Central body that is the origin of the thrust frame (if different from the vehicle, otherwise empty by default).

    returns:
        type: ThrustAccelerationSettings
        description: Thrust acceleration settings object.


